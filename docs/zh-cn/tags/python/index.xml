<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on 百里英骐的博客</title>
    <link>https://zhangsiming-blyq.github.io/zh-cn/tags/python/</link>
    <description>Recent content in python on 百里英骐的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Thu, 10 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangsiming-blyq.github.io/zh-cn/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>聊一聊golang、python中的闭包</title>
      <link>https://zhangsiming-blyq.github.io/zh-cn/post/closure/</link>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/zh-cn/post/closure/</guid>
      <description>
        
          
            本文为golang、python新手通俗地解释什么是闭包，以及在这两种语言中使用闭包时候需要注意的地方。本文运行的时候保留了package、import等重复的代码部分，为了方便大家复制下来自己跑一下，劣势是导致有部分冗杂，还请理解。
什么是闭包? a closure is a record storing a function together with an environment.
闭包的两大要素：函数和环境
函数：指的是在闭包实际实现的时候，往往通过调用一个外部函数返回其内部函数来实现的。内部函数可能是内部实名函数、匿名函数或者一段lambda表达式; 环境：在实际中引用环境是指外部函数的环境，闭包保存/记录了它产生时的外部函数的所有环境; 综上，闭包是一种延伸了作用域的函数，他会保留定义函数时存在的自由变量(未在本地作用域中绑定的变量)的绑定，这样调用函数时，所以定义作用域不可用了，但是仍能使用那些绑定。下面看一下闭包的常见用法：
golang:
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func outer() func(v int) { 6 x := 1 7 return func(v int) { 8 y := x + v 9 fmt.Println(x) 10 fmt.Println(y) 11 } 12} 13 14func main() { 15 a := outer() 16 a(1) 17 a(2) 18} 19 20// 输出结果 211 222 231 243 golang例子里面的逻辑中，a是一个闭包，闭包函数为内部的func(v int){}, 闭包环境为外部的x, 由于&#39;捕获&#39;了外部环境，所以每次执行闭包x都是1，最后输出结果1,2,1,3。
          
          
        
      </description>
    </item>
    
    <item>
      <title>python yield详解</title>
      <link>https://zhangsiming-blyq.github.io/zh-cn/post/python-yield/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/zh-cn/post/python-yield/</guid>
      <description>
        
          
            讲解python中迭代器、生成器、以及yield字段的常见使用场景。
Iterators python中对象实现了__iter__()和__next__()两个方法，我们就成它是可迭代对象(iterables)，通过__iter__()可以返回一个迭代器对象(iterators)
__iter__()方法：返回迭代器对象本身 __next__()方法：返回容器的下一个元素，在结尾时引发一个StopIteration异常终止迭代器 1lst = [1, 2, 3] 2print(type(lst)) 3new_iter = lst.__iter__() 4print(type(new_iter)) 5 6# Output 7&amp;lt;class &amp;#39;list&amp;#39;&amp;gt; 8&amp;lt;class &amp;#39;list_iterator&amp;#39;&amp;gt; for循环实际上就是通过__iter__()获取iterators，然后进行__next__()取值，直到StopIteration
Generators&amp;amp;yield Generators是一种特殊的迭代器(iterators)。如果函数中任意位置存在yield字段，当你调用函数，函数不会直接执行，而是会返回一个生成器(generators)。另外生成器(generators)还支持生成器表达式（类似于列表，只是将[]换成了()）
1def test(): 2 print(&amp;#34;for test&amp;#34;) 3 yield 0 4gen1 = test() 5print(type(gen1)) 6gen2 = (x*x for x in range(0, 3)) 7print(type(gen2)) 8 9# Output 10&amp;lt;class &amp;#39;generator&amp;#39;&amp;gt; 11&amp;lt;class &amp;#39;generator&amp;#39;&amp;gt; yield 区别于迭代器(iterators)会把所有的内容全部储存到内存中，生成器(generators)会随着__next__()的不断调用分配内存
每次生成器(generators)会运行到yield字段，然后将生成器(generators)状态保存返回；下次调用__next__()会继续从当前位置继续，到达下一个yield字段。一直到StopIteration停止。看一下下面例子：
1def test(): 2 print(&amp;#34;start&amp;#34;) 3 yield 0 4 print(&amp;#34;end&amp;#34;) 5 yield 1 6 7gen1 = test() 8print(gen1.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
