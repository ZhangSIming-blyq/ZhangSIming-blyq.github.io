[{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/","section":"","tags":null,"title":"Bailiyingqi's blog"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/","section":"categories","tags":null,"title":"Categories"},{"body":" For people new to Golang and Python, this article explains what closures are as well as sometips that need to know about when using closures in these two programming languages. To make it easier for you to copy down and run on your own server, the code section would provide the package, import, and other repeated parts. The negative aspect is that this results in some redundancy, so please understand if this causes any inconvenience.\nWhat Is Closures? a closure is a record storing a function together with an environment.\nClosure's two factors: function and environment\nfunction：Refers to the fact that when closures are actually implemented, they are often done by calling an external function that returns its internal function. An internal function may be an internal real-name function, an anonymous function, or a lambda expression. environment：In practice, the referenced environment is the environment of the external function and the closure holds/records all the environment of the external function at the time when it's being generated. To summarize, a closure is a function that extends the scope by retaining the bindings of free variables (variables not bound in the local scope) that existed when the function was defined, so that when the function is called, the definition scope is no longer available, but those bindings can still be used. Here is a look at the common usage of closures:\n1// golang version 2package main 3 4import \u0026#34;fmt\u0026#34; 5 6func outer() func(v int) { 7 x := 1 8 return func(v int) { 9 y := x + v 10 fmt.Println(x) 11 fmt.Println(y) 12 } 13} 14 15func main() { 16 a := outer() 17 a(1) 18 a(2) 19} 20 21// result 221 232 241 253 In the logic inside the golang example, \u0026quot;a\u0026quot; is a closure, the closure function is the internal func(v int){}, the closure environment is the external \u0026quot;x\u0026quot;, since the external environment is \u0026quot;captured\u0026quot;, so each execution of the closure \u0026quot;x\u0026quot; is 1, and the final output result is 1,2,1,3.\n1# python version 2def outer(): 3 x = 1 4 5 def inner(v): 6 y = x + v 7 print(x) 8 print(y) 9 return inner 10 11a = outer() 12a(1) 13a(2) 14 15# result 161 172 181 193 When comes to Python example, the same closure function is inner(v), the closure environment is \u0026quot;x\u0026quot;, so each time the closure is executed \u0026quot;x\u0026quot; is 1 (because the closure environment is captured), and then the logic inside the closure is to add \u0026quot;x\u0026quot; to the parameters passed in by the closure, so the final output is 1,2,1,3.\nClosures In Golang Anonymous Function Since anonymous functions are used very frequently in golang, let's start with this: Anonymous functions and the free variables they \u0026quot;capture\u0026quot; are called closures, and they are closed whether used normally, in a for loop, or in a defer:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x := 1 7 a := func(v int) { 8 y := x + v 9 fmt.Println(x) 10 fmt.Println(y) 11 } 12 a(2) 13 a(3) 14} 15 16// result 171 183 191 204 In the above example a is a closure, the closure function is the anonymous function func(v int){}, the closure environment is x, so the result is 1,3,1,4.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 y := 2 7 8 defer func() { 9 fmt.Println(y) 10 }() 11} 12 13// result 142 The same goes for the anonymous function in defer, which is func(){} in defer, and the closure environment is \u0026quot;y\u0026quot;, so the output is 2.\nModifies The Closure Environment First of all, all reference passing in golang is a value passing, if there is something like reference passing (which will also be mentioned later in this article for convenience), it is actually the \u0026quot;value\u0026quot; of the underlying pointer that is passed, thus achieving the so-called reference passing.\nIf you want to modify the closure environment inside the closure (in the closure function), golang is easy to do that. Owing to the fact that golang is a declarative language, assignment and declaration are written differently(:= for declaration, = for assignment); and golang closure \u0026quot;captures\u0026quot; the essence of the closure environment is reference passing rather than value passing, so directly modify it is ok, see the following example: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func make_avg() func(v int) { 6 count := 0 7 total := 0 8 return func(v int) { 9 count += 1 10 total += v 11 fmt.Println(float32(total)/float32(count)) 12 } 13} 14 15func main() { 16 a := make_avg() 17 a(1) 18 a(2) 19 a(3) 20} 21 22// result 231 241.5 252 The example is to calculate the average value, the closure is \u0026quot;a\u0026quot;, the closure function is the internal func(v int){} anonymous function, the closure environment is \u0026quot;count\u0026quot; and \u0026quot;total\u0026quot;; count += 1, total += v are direct modifications to the behavior of the closure environment and get the desired effect.\nSpecifically, you can use golang closures to \u0026quot;catch\u0026quot; the essence of the closure environment is reference passing this feature inside the anonymous function (inside the closure function) modify the global variables (closure environment), see the following example:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7var x int = 1 8 9func main() { 10 a := func() { 11 x += 1 12 } 13 fmt.Println(x) 14 a() 15 fmt.Println(x) 16} 17 18// result 191 202 Modify the closure environment outside the closure You must have some questions, \u0026quot;outside the closure\u0026quot; can modify the closure environment? In fact, it is possible in golang, remember the following two sentences:\nIf all the variables of the external function are local, that is, the life cycle ends when the external function ends, then the environment of the closure is also closed. Conversely, then the closure is no longer closed, and changes to globally visible variables will have an effect on the variables within the closure. Generally speaking, if the environment of a closure can be modified by a pointer, then the environment of the closure can be modified from outside the closure, see the following example:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func foo1(x *int) func() { 6 return func() { 7 *x = *x + 1 8 fmt.Println(*x) 9 } 10} 11func foo2(x int) func() { 12 return func() { 13 x = x + 1 14 fmt.Println(x) 15 } 16} 17 18func main() { 19 x := 133 20 f1 := foo1(\u0026amp;x) 21 f2 := foo2(x) 22 f1() 23 f1() 24 f2() 25 f2() 26 27 x = 233 28 f1() 29 f1() 30 f2() 31 f2() 32 33 foo1(\u0026amp;x)() 34 foo1(\u0026amp;x)() 35 foo2(x)() 36 foo2(x)() 37} The logic inside the two closures needs to be analyzed, one is the sum of pointer variables, according to what we said earlier, \u0026quot;the closure environment can be modified by pointers\u0026quot;, each time the closure is executed or directly assigned outside will really change the value of the variable, while the \u0026quot;foo2\u0026quot;, which does not use pointers, is the normal closure, that is, the closure environment is only inside the closure; so the first four groups of output as follows:\n1134 2135 3134 4135 The middle four groups are being accumulated by the \u0026quot;f1\u0026quot; closure on the modified 233 because the value of \u0026quot;x\u0026quot; is forced externally, and the \u0026quot;f2\u0026quot; closure is being accumulated in its own environment, so the output is:\n1234 2235 3136 4137 The last four groups generate four new closures, so the \u0026quot;foo1\u0026quot; part is still cumulative based on the current \u0026quot;x\u0026quot; value, and the cumulative value actually acts in the global variable \u0026quot;x\u0026quot;; the cumulative in foo2 is still inside its own closure, so the output is:\n1236 2237 3238 4238 With this example we distinguish between modifying the closure environment from inside the closure and from outside the closure.\nDelayed Binding Of Closures This problem is every golang newbie will encounter, very puzzling problem; please remember the following sentence: when executing the closure, the closure environment declaration cycle is guaranteed, and will go to the external environment to find the latest closure environment (value), the following example when executing the closure \u0026quot;i\u0026quot; is the closure environment, when executing the closure the latest value is already 10, so all will output 10.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var handlers []func() 7 for i := 0; i \u0026lt; 10; i++ { 8 handlers = append(handlers, func() { 9 fmt.Println(i) 10 }) 11 } 12 for _, handler := range handlers { 13 handler() 14 } 15} 16 17// result 1810 1910 2010 2110 2210 2310 2410 2510 2610 2710 The solution is to copy an environment variable in the for loop that is not referenced by the closure, and then use that value instead of the closure environment, with the following modified version:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var handlers []func() 7 for i := 0; i \u0026lt; 10; i++ { 8 // a is not a closure environment because it is redeclared each time 9 a := i 10 handlers = append(handlers, func() { 11 fmt.Println(a) 12 }) 13 } 14 for _, handler := range handlers { 15 handler() 16 } 17} 18 19// result 200 211 222 233 244 255 266 277 288 299 In fact, the principle is clear, it is not about the for loop, normal use, defer use will be bound by this principle, the execution of the closure, the closure environment declaration cycle is guaranteed, and will go to the external environment to find the latest closure environment (value)\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x, y := 1, 2 7 8 defer func(a int) { 9 fmt.Println(a, y) 10 }(x) 11 12 x += 100 13 y += 100 14} 15 16// The output, y, is the closure environment, so the execution of the closure will go to the latest value, while a is not the closure environment, copying the value of x so it is not implicated 171 102 The use of anonymous functions in go routines is a common scenario and suffers from this problem, see the following example:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func show(val int) { 9 fmt.Println(val) 10} 11 12func main() { 13 values := []int{1, 2, 3, 5} 14 for _, val := range values { 15 go show(val) 16 } 17 time.Sleep(time.Second) 18} 19 20// The four outputs 1,2,3,5 will be output each time, although in a different order, because no anonymous function is used, and it is not a closure 215 221 233 242 The four outputs 1,2,3,5 will be output each time, although in a different order, because no anonymous function is used, and it is not a closure.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 values := []int{1, 2, 3, 5} 10 for _, val := range values { 11 go func(){ 12 fmt.Println(val) 13 }() 14 } 15 time.Sleep(time.Second) 16} 17 18// output 195 205 215 225 The modification method is the same as inside the for loop example, using passing variables to avoid the closure environment.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 values := []int{1, 2, 3, 5} 10 for _, val := range values { 11 go func(val int){ 12 fmt.Println(val) 13 }(val) 14 } 15 time.Sleep(time.Second) 16} 17 18// output 191 205 213 222 Closures In Python Modifies The Closure Environment Modifying the closure environment from within Since python is not a declarative language, a \u0026quot;=\u0026quot; eats all, we need to use the nonlocal parameter to explicitly declare the variable as a closure environment, and not a local variable, look at the following example, if the same way as golang directly change, sometimes there will be a problem.\nuse Python list as a closure environment\n1def make_avg(count, total): 2 count = [] 3 4 def avg(v): 5 count.append(v) 6 total = sum(count) 7 print(sum(count)/len(count)) 8 return avg 9 10 11a = make_avg(0, 0) 12a(1) 13a(2) 14a(3) 15 16 17# output 181.0 191.5 202.0 use Python character as a closure environment\n1def make_avg(count, total): 2 count = 0 3 total = 0 4 5 def avg(v): 6 count += 1 7 total += v 8 print(total/count) 9 return avg 10 11 12a = make_avg(0, 0) 13a(1) 14a(2) 15a(3) 16 17 18# error 19Traceback (most recent call last): 20 File \u0026#34;/root/code/linux/blog/aa.py\u0026#34;, line 14, in \u0026lt;module\u0026gt; 21 a(1) 22 File \u0026#34;/root/code/linux/blog/aa.py\u0026#34;, line 7, in avg 23 count += 1 24UnboundLocalError: local variable \u0026#39;count\u0026#39; referenced before assignment That is because python has two types of data, one for mutable data types, one for immutable data types, when passing variable data types use reference passing, this and golang closure directly modified characteristics match, but immutable data types such as the above string will be a problem, because python will take him as a newly generated local variables, so the solution is to use nonlocal to tell the python interpreter, This variable is for the closure environment, so that it can run properly, the correct way to write the following:\n1def make_avg(count, total): 2 count = 0 3 total = 0 4 5 def avg(v): 6 nonlocal count, total 7 count += 1 8 total += v 9 print(total/count) 10 return avg 11 12 13a = make_avg(0, 0) 14a(1) 15a(2) 16a(3) 17 18# output 191.0 201.5 212.0 Closures And Decorators I was going to talk about python decorators, but I decided to leave it for another time because there is already a lot of space here.\nSummary There are many examples above, after reading each example, to understand why, then the closure problem will be solved;\nKeep in mind, cuz the closure is not commonly used, personal feeling is not very practical, if the work is not necessary to use the closure when you must not force the practical closure forced, or pretend not to engage in memory leaks instead is not a small problem.\ntwo main elements of the closure: function and environment closure is a function that extends the scope, it will retain the bindings of free variables (variables not bound in the local scope) that existed when the function was defined, so when the function is called, so the definition scope is not available, but can still use those bindings the use of anonymous functions in golang is actually a closure the closure environment variables can be modified from outside the closure by pointers golang closures delayed binding problem: when executing a closure, the declaration cycle of the closure environment is guaranteed, and it will go to the external environment to find the latest closure environment (value) python closures use nonlocal to declare variables as closure environment, instead of local variables The above analysis is my understanding of the closure, I hope golang, python newcomers can avoid a must-step pit after reading, if you have questions about the environment feel free to comment or email contact, thank you.\nReference Links\nhttps://juejin.cn/post/6844904133208604679\nhttps://www.jianshu.com/p/fa21e6fada70\nhttps://zhuanlan.zhihu.com/p/92634505\n","link":"https://zhangsiming-blyq.github.io/en-us/post/golang/closure/","section":"post","tags":["golang","python"],"title":"Closures In Golang And Python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/golang/","section":"tags","tags":null,"title":"golang"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/golang/","section":"categories","tags":null,"title":"golang"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/python/","section":"categories","tags":null,"title":"python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/archives/","section":"","tags":null,"title":"Archives"},{"body":"+++ title = \u0026quot;Search\u0026quot; searchPage = true type = \u0026quot;search\u0026quot; +++\n","link":"https://zhangsiming-blyq.github.io/en-us/search/","section":"","tags":null,"title":""},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/about/","section":"tags","tags":null,"title":"about"},{"body":"Embrace the IT World: A Guide to Kubernetes, Go Language, Python, Shell, and Linux\nIntroduction The world of information technology is rapidly evolving, and it can be challenging to keep up with the latest developments. However, with the right mindset, tools, and resources, you can not only keep up but also excel in this field. In this blog post, we will explore some of the most important topics in the IT world, including Kubernetes, Golang, Python, Shell, and Linux. Whether you are a beginner or an experienced IT professional, this guide will provide you with valuable insights and practical tips to help you succeed in your career.\nLife Advices Don't stop learning; continually acquire new knowledge and skills to help you improve your work and boost your confidence.\nBuild strong relationships: Focus on building strong relationships with your family, friends and colleagues. Surround yourself with positive and supportive people who will inspire and motivate you to be your best self.\nTake risks: Don't be afraid to take risks and try new things. Failure is often the best teacher and it can help you learn and grow as a person. Taking calculated risks will help you step out of your comfort zone and gain valuable experience.\nLearn to manage your finances wisely, including budgeting, saving, and investing. This will provide financial stability and security for your future.\nWork-life balance is crucial. You should also schedule time for your favorite hobbies and allocated some personal leisure.\nStay healthy: Take care of your physical and mental health. Get enough sleep, eat a balanced diet, exercise regularly and take time to de-stress. This will help you maintain a positive outlook on life and enjoy it to the fullest.\nLearn from your mistakes: Nobody is perfect, and we all make mistakes. Instead of dwelling on your mistakes, focus on learning from them and growing as a person.\nPursue your passions: Pursue what makes you happy, whether it's a hobby(money, healthy, creative, knowledge, mindset) or a career. Finding meaning and purpose in your life will give you a sense of fulfillment and happiness.\nTime is your most valuable resource. Use it wisely and prioritize the things that matter most to you.\nSet goals and create a plan to achieve them. This will give you direction and purpose in life.\nConclusion By mastering Kubernetes, Golang, Python, Shell, and Linux, you can become a well-rounded IT professional with a diverse set of skills and knowledge. These technologies are not only useful for building cutting-edge software and systems but also for improving your productivity, efficiency, and problem-solving abilities. Remember, it's never too late to start studying and making progress. Stay focused, stay motivated, and do your best.\nAs a reminder, all content on this website is based on the principles of spreading positive energy and promoting mutual learning. We may reference some publicly available content on the internet. If there is any copyright infringement, please contact us at 1030728296@qq.com to request removal. Thank you for your understanding and support.\n","link":"https://zhangsiming-blyq.github.io/en-us/about/","section":"","tags":["about","bailiyingqi"],"title":"About me"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/bailiyingqi/","section":"tags","tags":null,"title":"bailiyingqi"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/series/","section":"series","tags":null,"title":"Series"}]