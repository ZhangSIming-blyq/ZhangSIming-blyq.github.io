[{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/","section":"","tags":null,"title":"Bailiyingqi's blog"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/","section":"categories","tags":null,"title":"Categories"},{"body":" For people new to Golang and Python, this article explains what closures are as well as sometips that need to know about when using closures in these two programming languages. To make it easier for you to copy down and run on your own server, the code section would provide the package, import, and other repeated parts. The negative aspect is that this results in some redundancy, so please understand if this causes any inconvenience.\nWhat Is Closures? a closure is a record storing a function together with an environment.\nClosure's two factors: function and environment\nfunction：Refers to the fact that when closures are actually implemented, they are often done by calling an external function that returns its internal function. An internal function may be an internal real-name function, an anonymous function, or a lambda expression. environment：In practice, the referenced environment is the environment of the external function and the closure holds/records all the environment of the external function at the time when it's being generated. To summarize, a closure is a function that extends the scope by retaining the bindings of free variables (variables not bound in the local scope) that existed when the function was defined, so that when the function is called, the definition scope is no longer available, but those bindings can still be used. Here is a look at the common usage of closures:\n1// golang version 2package main 3 4import \u0026#34;fmt\u0026#34; 5 6func outer() func(v int) { 7 x := 1 8 return func(v int) { 9 y := x + v 10 fmt.Println(x) 11 fmt.Println(y) 12 } 13} 14 15func main() { 16 a := outer() 17 a(1) 18 a(2) 19} 20 21// result 221 232 241 253 In the logic inside the golang example, \u0026quot;a\u0026quot; is a closure, the closure function is the internal func(v int){}, the closure environment is the external \u0026quot;x\u0026quot;, since the external environment is \u0026quot;captured\u0026quot;, so each execution of the closure \u0026quot;x\u0026quot; is 1, and the final output result is 1,2,1,3.\n1# python version 2def outer(): 3 x = 1 4 5 def inner(v): 6 y = x + v 7 print(x) 8 print(y) 9 return inner 10 11a = outer() 12a(1) 13a(2) 14 15# result 161 172 181 193 When comes to Python example, the same closure function is inner(v), the closure environment is \u0026quot;x\u0026quot;, so each time the closure is executed \u0026quot;x\u0026quot; is 1 (because the closure environment is captured), and then the logic inside the closure is to add \u0026quot;x\u0026quot; to the parameters passed in by the closure, so the final output is 1,2,1,3.\nClosures In Golang Anonymous Function Since anonymous functions are used very frequently in golang, let's start with this: Anonymous functions and the free variables they \u0026quot;capture\u0026quot; are called closures, and they are closed whether used normally, in a for loop, or in a defer:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x := 1 7 a := func(v int) { 8 y := x + v 9 fmt.Println(x) 10 fmt.Println(y) 11 } 12 a(2) 13 a(3) 14} 15 16// result 171 183 191 204 In the above example a is a closure, the closure function is the anonymous function func(v int){}, the closure environment is x, so the result is 1,3,1,4.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 y := 2 7 8 defer func() { 9 fmt.Println(y) 10 }() 11} 12 13// result 142 The same goes for the anonymous function in defer, which is func(){} in defer, and the closure environment is \u0026quot;y\u0026quot;, so the output is 2.\nModifies The Closure Environment First of all, all reference passing in golang is a value passing, if there is something like reference passing (which will also be mentioned later in this article for convenience), it is actually the \u0026quot;value\u0026quot; of the underlying pointer that is passed, thus achieving the so-called reference passing.\nIf you want to modify the closure environment inside the closure (in the closure function), golang is easy to do that. Owing to the fact that golang is a declarative language, assignment and declaration are written differently(:= for declaration, = for assignment); and golang closure \u0026quot;captures\u0026quot; the essence of the closure environment is reference passing rather than value passing, so directly modify it is ok, see the following example: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func make_avg() func(v int) { 6 count := 0 7 total := 0 8 return func(v int) { 9 count += 1 10 total += v 11 fmt.Println(float32(total)/float32(count)) 12 } 13} 14 15func main() { 16 a := make_avg() 17 a(1) 18 a(2) 19 a(3) 20} 21 22// result 231 241.5 252 The example is to calculate the average value, the closure is \u0026quot;a\u0026quot;, the closure function is the internal func(v int){} anonymous function, the closure environment is \u0026quot;count\u0026quot; and \u0026quot;total\u0026quot;; count += 1, total += v are direct modifications to the behavior of the closure environment and get the desired effect.\nSpecifically, you can use golang closures to \u0026quot;catch\u0026quot; the essence of the closure environment is reference passing this feature inside the anonymous function (inside the closure function) modify the global variables (closure environment), see the following example:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7var x int = 1 8 9func main() { 10 a := func() { 11 x += 1 12 } 13 fmt.Println(x) 14 a() 15 fmt.Println(x) 16} 17 18// result 191 202 Modify the closure environment outside the closure You must have some questions, \u0026quot;outside the closure\u0026quot; can modify the closure environment? In fact, it is possible in golang, remember the following two sentences:\nIf all the variables of the external function are local, that is, the life cycle ends when the external function ends, then the environment of the closure is also closed. Conversely, then the closure is no longer closed, and changes to globally visible variables will have an effect on the variables within the closure. Generally speaking, if the environment of a closure can be modified by a pointer, then the environment of the closure can be modified from outside the closure, see the following example:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func foo1(x *int) func() { 6 return func() { 7 *x = *x + 1 8 fmt.Println(*x) 9 } 10} 11func foo2(x int) func() { 12 return func() { 13 x = x + 1 14 fmt.Println(x) 15 } 16} 17 18func main() { 19 x := 133 20 f1 := foo1(\u0026amp;x) 21 f2 := foo2(x) 22 f1() 23 f1() 24 f2() 25 f2() 26 27 x = 233 28 f1() 29 f1() 30 f2() 31 f2() 32 33 foo1(\u0026amp;x)() 34 foo1(\u0026amp;x)() 35 foo2(x)() 36 foo2(x)() 37} The logic inside the two closures needs to be analyzed, one is the sum of pointer variables, according to what we said earlier, \u0026quot;the closure environment can be modified by pointers\u0026quot;, each time the closure is executed or directly assigned outside will really change the value of the variable, while the \u0026quot;foo2\u0026quot;, which does not use pointers, is the normal closure, that is, the closure environment is only inside the closure; so the first four groups of output as follows:\n1134 2135 3134 4135 The middle four groups are being accumulated by the \u0026quot;f1\u0026quot; closure on the modified 233 because the value of \u0026quot;x\u0026quot; is forced externally, and the \u0026quot;f2\u0026quot; closure is being accumulated in its own environment, so the output is:\n1234 2235 3136 4137 The last four groups generate four new closures, so the \u0026quot;foo1\u0026quot; part is still cumulative based on the current \u0026quot;x\u0026quot; value, and the cumulative value actually acts in the global variable \u0026quot;x\u0026quot;; the cumulative in foo2 is still inside its own closure, so the output is:\n1236 2237 3238 4238 With this example we distinguish between modifying the closure environment from inside the closure and from outside the closure.\nDelayed Binding Of Closures This problem is every golang newbie will encounter, very puzzling problem; please remember the following sentence: when executing the closure, the closure environment declaration cycle is guaranteed, and will go to the external environment to find the latest closure environment (value), the following example when executing the closure \u0026quot;i\u0026quot; is the closure environment, when executing the closure the latest value is already 10, so all will output 10.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var handlers []func() 7 for i := 0; i \u0026lt; 10; i++ { 8 handlers = append(handlers, func() { 9 fmt.Println(i) 10 }) 11 } 12 for _, handler := range handlers { 13 handler() 14 } 15} 16 17// result 1810 1910 2010 2110 2210 2310 2410 2510 2610 2710 The solution is to copy an environment variable in the for loop that is not referenced by the closure, and then use that value instead of the closure environment, with the following modified version:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var handlers []func() 7 for i := 0; i \u0026lt; 10; i++ { 8 // a is not a closure environment because it is redeclared each time 9 a := i 10 handlers = append(handlers, func() { 11 fmt.Println(a) 12 }) 13 } 14 for _, handler := range handlers { 15 handler() 16 } 17} 18 19// result 200 211 222 233 244 255 266 277 288 299 In fact, the principle is clear, it is not about the for loop, normal use, defer use will be bound by this principle, the execution of the closure, the closure environment declaration cycle is guaranteed, and will go to the external environment to find the latest closure environment (value)\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x, y := 1, 2 7 8 defer func(a int) { 9 fmt.Println(a, y) 10 }(x) 11 12 x += 100 13 y += 100 14} 15 16// The output, y, is the closure environment, so the execution of the closure will go to the latest value, while a is not the closure environment, copying the value of x so it is not implicated 171 102 The use of anonymous functions in go routines is a common scenario and suffers from this problem, see the following example:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func show(val int) { 9 fmt.Println(val) 10} 11 12func main() { 13 values := []int{1, 2, 3, 5} 14 for _, val := range values { 15 go show(val) 16 } 17 time.Sleep(time.Second) 18} 19 20// The four outputs 1,2,3,5 will be output each time, although in a different order, because no anonymous function is used, and it is not a closure 215 221 233 242 The four outputs 1,2,3,5 will be output each time, although in a different order, because no anonymous function is used, and it is not a closure.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 values := []int{1, 2, 3, 5} 10 for _, val := range values { 11 go func(){ 12 fmt.Println(val) 13 }() 14 } 15 time.Sleep(time.Second) 16} 17 18// output 195 205 215 225 The modification method is the same as inside the for loop example, using passing variables to avoid the closure environment.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 values := []int{1, 2, 3, 5} 10 for _, val := range values { 11 go func(val int){ 12 fmt.Println(val) 13 }(val) 14 } 15 time.Sleep(time.Second) 16} 17 18// output 191 205 213 222 Closures In Python Modifies The Closure Environment Modifying the closure environment from within Since python is not a declarative language, a \u0026quot;=\u0026quot; eats all, we need to use the nonlocal parameter to explicitly declare the variable as a closure environment, and not a local variable, look at the following example, if the same way as golang directly change, sometimes there will be a problem.\nuse Python list as a closure environment\n1def make_avg(count, total): 2 count = [] 3 4 def avg(v): 5 count.append(v) 6 total = sum(count) 7 print(sum(count)/len(count)) 8 return avg 9 10 11a = make_avg(0, 0) 12a(1) 13a(2) 14a(3) 15 16 17# output 181.0 191.5 202.0 use Python character as a closure environment\n1def make_avg(count, total): 2 count = 0 3 total = 0 4 5 def avg(v): 6 count += 1 7 total += v 8 print(total/count) 9 return avg 10 11 12a = make_avg(0, 0) 13a(1) 14a(2) 15a(3) 16 17 18# error 19Traceback (most recent call last): 20 File \u0026#34;/root/code/linux/blog/aa.py\u0026#34;, line 14, in \u0026lt;module\u0026gt; 21 a(1) 22 File \u0026#34;/root/code/linux/blog/aa.py\u0026#34;, line 7, in avg 23 count += 1 24UnboundLocalError: local variable \u0026#39;count\u0026#39; referenced before assignment That is because python has two types of data, one for mutable data types, one for immutable data types, when passing variable data types use reference passing, this and golang closure directly modified characteristics match, but immutable data types such as the above string will be a problem, because python will take him as a newly generated local variables, so the solution is to use nonlocal to tell the python interpreter, This variable is for the closure environment, so that it can run properly, the correct way to write the following:\n1def make_avg(count, total): 2 count = 0 3 total = 0 4 5 def avg(v): 6 nonlocal count, total 7 count += 1 8 total += v 9 print(total/count) 10 return avg 11 12 13a = make_avg(0, 0) 14a(1) 15a(2) 16a(3) 17 18# output 191.0 201.5 212.0 Closures And Decorators I was going to talk about python decorators, but I decided to leave it for another time because there is already a lot of space here.\nSummary There are many examples above, after reading each example, to understand why, then the closure problem will be solved;\nKeep in mind, cuz the closure is not commonly used, and it is not very practical, you don't have to use closures if the work is not necessary to use. Or may trigger some memory leaks, which is not a small problem.\ntwo main elements of the closure: function and environment closure is a function that extends the scope, it will retain the bindings of free variables (variables not bound in the local scope) that existed when the function was defined, so when the function is called, so the definition scope is not available, but can still use those bindings the use of anonymous functions in golang is actually a closure the closure environment variables can be modified from outside the closure by pointers golang closures delayed binding problem: when executing a closure, the declaration cycle of the closure environment is guaranteed, and it will go to the external environment to find the latest closure environment (value) python closures use nonlocal to declare variables as closure environment, instead of local variables The above analysis is my understanding of the closure, I hope golang, python newcomers can avoid a must-step pit after reading, if you have questions about the environment feel free to comment or email contact, thank you.\nReference Links\nhttps://juejin.cn/post/6844904133208604679\nhttps://www.jianshu.com/p/fa21e6fada70\nhttps://zhuanlan.zhihu.com/p/92634505\n","link":"https://zhangsiming-blyq.github.io/en-us/post/golang/closure/","section":"post","tags":["golang","python"],"title":"Closures In Golang And Python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/golang/","section":"tags","tags":null,"title":"golang"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/golang/","section":"categories","tags":null,"title":"golang"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/python/","section":"categories","tags":null,"title":"python"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/archives/","section":"","tags":null,"title":"Archives"},{"body":" Explain the common usage scenarios of iterators, generators, and yield fields in Python.\nIterators Python object implements iter() and next() methods, we become iterable objects (iterables), through iter() can return an iterator object (iterators).\n__iter__() method: return the iterator object itself __next__() method: returns the next element of the container, and raises a StopIteration Exception at the end to terminate the iterator 1lst = [1, 2, 3] 2print(type(lst)) 3new_iter = lst.__iter__() 4print(type(new_iter)) 5 6# Output 7\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; 8\u0026lt;class \u0026#39;list_iterator\u0026#39;\u0026gt; The for loop actually gets iterators by iter() and then does next() to fetch until StopIteration.\nGenerators\u0026amp;yield Generators are a special kind of iterators. If a field exists anywhere in the function, when you call the function, the function will not execute directly, but will return a generator. In addition generators also support generator expressions (similar to lists, except that [] is replaced with ()).\n1def test(): 2 print(\u0026#34;for test\u0026#34;) 3 yield 0 4gen1 = test() 5print(type(gen1)) 6gen2 = (x*x for x in range(0, 3)) 7print(type(gen2)) 8 9# Output 10\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; 11\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; yield Unlike iterators, which store all of their content in memory, generators allocate memory as next() is called over and over again.\nEach time generators will run to the yield field, then save the generator state and return; the next call to next() will continue from the current position to the next yield field. This continues until StopIteration stops. Take a look at the following example:\n1def test(): 2 print(\u0026#34;start\u0026#34;) 3 yield 0 4 print(\u0026#34;end\u0026#34;) 5 yield 1 6 7gen1 = test() 8print(gen1.__next__()) 9print(gen1.__next__()) 10 11print(\u0026#34;\u0026#34;) 12gen2 = (x*x for x in range(0, 3)) 13print(gen2.__next__()) 14print(gen2.__next__()) 15print(gen2.__next__()) 16print(gen2.__next__()) 17 18# Output 19start 200 21end 221 23 240 251 264 27Traceback (most recent call last): 28 File \u0026#34;/home/vagrant/aa.py\u0026#34;, line 16, in \u0026lt;module\u0026gt; 29 print(gen2.__next__()) 30StopIteration Yield In Action We have a batch of 100 pieces of data in a list and want to divide it into 10 groups of 10 and process them separately:\n1def chunks(lst, n): 2 \u0026#34;\u0026#34;\u0026#34;Yield successive n-sized chunks from lst.\u0026#34;\u0026#34;\u0026#34; 3 for i in range(0, len(lst), n): 4 yield lst[i:i + n] 5 6origin_lst = list(range(0, 100)) 7for i in chunks(origin_lst, 10): 8 print(i) 9 10# Output 11[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 12[10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 13[20, 21, 22, 23, 24, 25, 26, 27, 28, 29] 14[30, 31, 32, 33, 34, 35, 36, 37, 38, 39] 15[40, 41, 42, 43, 44, 45, 46, 47, 48, 49] 16[50, 51, 52, 53, 54, 55, 56, 57, 58, 59] 17[60, 61, 62, 63, 64, 65, 66, 67, 68, 69] 18[70, 71, 72, 73, 74, 75, 76, 77, 78, 79] 19[80, 81, 82, 83, 84, 85, 86, 87, 88, 89] 20[90, 91, 92, 93, 94, 95, 96, 97, 98, 99] Reference Links:\nhttps://blog.csdn.net/Yuyh131/article/details/83310486 https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do ","link":"https://zhangsiming-blyq.github.io/en-us/post/python/python-yield/","section":"post","tags":["python"],"title":"Python Yield"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/finance/","section":"tags","tags":null,"title":"finance"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/categories/finance/","section":"categories","tags":null,"title":"finance"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/fund/","section":"tags","tags":null,"title":"fund"},{"body":" Warren Buffett, the stock god, said, \u0026quot;By investing regularly in index funds, an amateur investor who knows nothing can surprisingly often beat most professional investors; index funds track indices and do not rely too much on fund managers; each index fund will invest in dozens or even hundreds of stocks at the same time, which can maximize the diversification of investors' non-market risks; and among all similar index funds also have the lowest fees of all funds of their kind.\u0026quot;\nBroad-based index funds SSE 50 Index: The SSE selects the largest, most liquid and representative 50 stocks in Shanghai to form the sample stocks, reflecting the overall situation of the most influential group of outstanding large-cap companies in Shanghai Shanghai and Shenzhen 300 Index: developed by CSI Index Company, the largest and most liquid 300 stocks selected from the SSE and SZSE, the most representative index of the domestic stock market CSI 500 Index: All 300 companies in the CSI 300 Index are excluded, and then the top 300 companies in terms of average daily market capitalization in the recent year are also excluded, and the top 500 companies in terms of average daily market capitalization are selected from the remaining companies as the CSI 500 Index GEM Index: placed under the Shenzhen Stock Exchange, it is a lower threshold market for small enterprises that cannot meet the listing requirements of the Main Board; GEM Composite Index refers to the average performance of the share prices of all GEM listed companies; GEM Index is a reflection of the average performance of the top 100 companies on the GEM The above four indices are weighted according to market capitalization; the larger the stock size, the higher the weighting in the index.\nDividend Index: is a relatively special category of strategy-weighted funds that have emerged in the last decade or so; we all know that stocks pay dividends, that is, cash dividends; companies with better performance will take out a portion of their net profits each year to give back to shareholders in the form of cash dividends; and dividend indices are weighted according to dividends to form index funds. The common ones are SSE Dividend Index, CSI Dividend Index, SZ Dividend Index and Dividend Opportunity Index Fundamental Index: Fundamentals basically cover all aspects of a company's operation, such as operating income, cash flow, net assets, dividends, etc., and are weighted according to fundamentals, called fundamental indices. CCTV Finance 50 Index: 50 stocks selected by experts' votes, which are closely related to experts' stock selection ability Hang Seng Index: investing in the 50 largest companies listed in Hong Kong, China H-share index: the company is registered in the mainland, but listed in Hong Kong, such companies are H-shares; the whole H-share index is the Hang Seng China Enterprises Index SSE 50 AH Preferred Index: many companies are listed in both A and H shares, which are closely related; buy the relatively cheap one of AH shares and sell the relatively expensive one, using this principle to obtain excess returns of the composition of the SSE 50 AH Preferred Index Nasdaq 100 Index: the largest 100 large companies in the U.S. stock Nasdaq S\u0026amp;P 500 Index: mainly large-cap stocks, with 500 constituents; S\u0026amp;P 500 is a blue-chip index with subjective judgment, including the distribution of companies in various industries, large and small companies are more evenly selected SSE Composite Index: all listed companies on the SSE CSI 100 Index: a selection of the top 100 of the CSI 300, as well as similar CSI 800, CSI 1000 and CSI All Ordinaries Equally Weighted Index: Equally weighted indices are assigned the exact same weight to each constituent stock Sector Index Funds Top sectors: essential consumption: mainly various consumer goods needed to maintain our normal life, such as beverages, wine, agricultural and sideline food, etc. Pharmaceutical industry: everyone can't live without old age, sickness and death, medicine is a basic human need optional consumption: beverages, tobacco and other common consumer goods, generally lower unit price, consumption frequency, but also the immediate needs Aging industry: a multi-industry mixed industry, covering a number of industries, including health care, information technology, daily consumption, optional consumption, and even financial industries such as insurance companies Strongly cyclical industries banking industry: the cyclicality of banks is influenced by the macroeconomy, the economy is in the down cycle, the bank carry income is reduced, the benefits become worse; when the economy improves, the bank benefits will become better securities industry real estate industry Others: military industry environmental protection industry liquor industry Common valuation indicators price-earnings ratio: the company's market value / company earnings, reflecting how much we are willing to pay to get 1 yuan of net profit (P/E ratio of 10 means we are willing to pay 10 yuan for 1 yuan of earnings); can also be extrapolated to estimate the market value (based on the company's annual net profit multiplied by the P/E ratio can calculate the market value); applicable to companies with good liquidity and stable earnings earnings yield: company earnings / company market value, in general, the higher the earnings yield the lower the valuation of the company, the more likely the company is undervalued; applicable to good liquidity, stable earnings company P/N ratio: market value of the company / net assets of the company, net assets is assets minus liabilities; when most of the company's assets are tangible assets that can be easily measured, and assets that retain their value over time, it is more appropriate to use the P/N ratio for valuation Dividend rate: the company's cash dividends in the past year / the company's market value, the dividend rate measures the yield of cash dividends; earnings yield * dividend rate = dividend rate; dividend rate is generally set in advance by the company, and will not change for many years; dividend rate will fluctuate with the stock price, the lower the stock price, the higher the dividend rate For index valuation, please refer to a Wechat official account \u0026quot;Bank Screws\u0026quot; for more information.\nIndex Fund Selection Earnings Yield Method: Investment method 1:\nWhen the earnings yield is greater than 10%, start (stick to) fixed investment when the earnings yield is less than 10%, more than 6.4%, suspend the fixed investment, continue to hold; can be fixed in other varieties of earnings yield greater than 10% When the profit yield is less than 6.4%, sell in batches Scope of application: good liquidity, more stable profit varieties:\nIndexes: SSE 50, SSE Dividend, CSI Dividend, Fundamental 50, CCTV 50, SSE 50 AH Preferred, Hang Seng Index, H-share Index\nBorg formula method: The future compound annual return of an index fund is equal to the initial dividend yield of the index fund's investment, plus the annual change in the index fund's P/E ratio, plus the annual change in the index fund's earnings:\nDividend yield: obtained from the notary number valuation P/E ratio: P/E ratio is cyclical, if you look at the historical P/E ratio is at a lower level then the probability is that the future will rise, and this time should buy earnings: the general situation of domestic economic rise will bring positive returns Investment method:\nwhen the P/E ratio is at the bottom of the history of the region adhere to the fixed investment the P/E ratio into the normal valuation, suspend fixed investment, continue to hold; can be fixed investment in other products at the bottom sell when the P/E ratio enters the higher region of history Scope of application: the index whose earnings are in a high growth posture, you can use the Borg formula to judge it. If the current P/E ratio of the index is in the lower region of its historical P/E fluctuation range, you can invest in it\nIndexes: CSI 300, CSI 500, GEM, Dividend Opportunity Index, Essential Consumer Sector Index, Pharmaceutical Sector Index, Optional Consumer Sector Index, Pension Industry Index\nBorg formula method-variant: The future compound annual return of the index fund, equal to the annual rate of change of the index fund's P/N ratio, plus the annual rate of change of the index fund's net assets\nInvestment Methodology:\ninsist on fixed investment when the P/N ratio is at the historical bottom area When the P/N ratio enters normal valuation, suspend investment and continue to hold; you can invest in other products that are at the bottom sell when the P/N ratio enters the historical high region Scope of application: earnings in an unstable state or earnings are cyclical, but the industry does not have a long-term loss record of the index\nIndices: securities industry index, financial industry index, non-banking financial industry index, real estate industry index\nInvest in index funds when they are undervalued and worthwhile before making fixed investments\nFive tips to improve the return on fixed investment Save is to earn: reduce the fees of trading funds Proper handling of fund dividends can bring long-term returns up a notch (earnings continue to be invested) fixed investment frequency selection: long-term earnings, a month of investment and a week of investment earnings are almost the same; if you see a big drop in the month can not help but add suggested two weeks or a week of investment can be regular variable (earnings yield method): the earnings yield for the first time to reach 10% or more to start investing the amount of funds as a benchmark, the amount of fixed investment each month thereafter can be calculated using the following formula: the first low fixed investment * (the earnings yield for the month / the first earnings yield) regular variable (Borg formula method): the fixed investment amount at the first underestimation * (first P/E ratio / P/E ratio of the month); for the Borg formula variant is: the fixed investment amount at the first underestimation * (first P/E ratio / P/E ratio of the month) How much money should I put into an index fund? for those who have some liquid assets in hand, you can subtract your current age from 100 and use the resulting value plus the percentage sign to determine the proportion of funds suitable for investment in index funds; for office workers: (monthly income - various expenses) * 0.5 of the funds as index funds fixed investment is more reasonable; it is recommended that part of the index funds, another part of money funds Warren Buffett sold the three conditions fundamental deterioration: if the country's macro economy goes downhill, then the index fund is not worth holding too expensive: should strictly comply with the earnings yield below 6.4% to sell there are better varieties Fixed Investment Schedule Date Operation (buy/sell) Transaction Variety Code Buy or sell amount Transaction unit price Buy or sell share Valuation at the time of buy or sell ","link":"https://zhangsiming-blyq.github.io/en-us/post/indexfund/","section":"post","tags":["fund","finance"],"title":"Index Fund Investment Guide Digest"},{"body":"+++ title = \u0026quot;Search\u0026quot; searchPage = true type = \u0026quot;search\u0026quot; +++\n","link":"https://zhangsiming-blyq.github.io/en-us/search/","section":"","tags":null,"title":""},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/about/","section":"tags","tags":null,"title":"about"},{"body":"Embrace the IT World: A Guide to Kubernetes, Go Language, Python, Shell, and Linux\nIntroduction The world of information technology is rapidly evolving, and it can be challenging to keep up with the latest developments. However, with the right mindset, tools, and resources, you can not only keep up but also excel in this field. In this blog post, we will explore some of the most important topics in the IT world, including Kubernetes, Golang, Python, Shell, and Linux. Whether you are a beginner or an experienced IT professional, this guide will provide you with valuable insights and practical tips to help you succeed in your career.\nLife Advices Don't stop learning; continually acquire new knowledge and skills to help you improve your work and boost your confidence.\nBuild strong relationships: Focus on building strong relationships with your family, friends and colleagues. Surround yourself with positive and supportive people who will inspire and motivate you to be your best self.\nTake risks: Don't be afraid to take risks and try new things. Failure is often the best teacher and it can help you learn and grow as a person. Taking calculated risks will help you step out of your comfort zone and gain valuable experience.\nLearn to manage your finances wisely, including budgeting, saving, and investing. This will provide financial stability and security for your future.\nWork-life balance is crucial. You should also schedule time for your favorite hobbies and allocated some personal leisure.\nStay healthy: Take care of your physical and mental health. Get enough sleep, eat a balanced diet, exercise regularly and take time to de-stress. This will help you maintain a positive outlook on life and enjoy it to the fullest.\nLearn from your mistakes: Nobody is perfect, and we all make mistakes. Instead of dwelling on your mistakes, focus on learning from them and growing as a person.\nPursue your passions: Pursue what makes you happy, whether it's a hobby(money, healthy, creative, knowledge, mindset) or a career. Finding meaning and purpose in your life will give you a sense of fulfillment and happiness.\nTime is your most valuable resource. Use it wisely and prioritize the things that matter most to you.\nSet goals and create a plan to achieve them. This will give you direction and purpose in life.\nConclusion By mastering Kubernetes, Golang, Python, Shell, and Linux, you can become a well-rounded IT professional with a diverse set of skills and knowledge. These technologies are not only useful for building cutting-edge software and systems but also for improving your productivity, efficiency, and problem-solving abilities. Remember, it's never too late to start studying and making progress. Stay focused, stay motivated, and do your best.\nAs a reminder, all content on this website is based on the principles of spreading positive energy and promoting mutual learning. We may reference some publicly available content on the internet. If there is any copyright infringement, please contact us at 1030728296@qq.com to request removal. Thank you for your understanding and support.\n","link":"https://zhangsiming-blyq.github.io/en-us/about/","section":"","tags":["about","bailiyingqi"],"title":"About me"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/tags/bailiyingqi/","section":"tags","tags":null,"title":"bailiyingqi"},{"body":"","link":"https://zhangsiming-blyq.github.io/en-us/series/","section":"series","tags":null,"title":"Series"}]