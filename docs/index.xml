<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>百里英骐</title>
    <link>https://zhangsiming-blyq.github.io/</link>
    <description>Recent content on 百里英骐</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangsiming-blyq.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浅谈kubernetes ingress机制</title>
      <link>https://zhangsiming-blyq.github.io/post/ingress-mechanism/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/ingress-mechanism/</guid>
      <description>ingress在将流量发往后端的时候是不经过kube-proxy的，ingress controller会直接和kube-apiserver进行交互，然后获取pod endpoints和service的对应关系，进行轮询，负载均衡到后端节点。
 一、验证试验 从集群中删除kube-proxy，查看通过ingress的方式是否可以访问成功?
# 实验中选择的是&amp;#34;iptables模式的kube-proxy&amp;#34; # 首先关闭kube-proxy $ sudo systemctl stop kube-proxy # 查看服务，ClusterIP的端口是8080，NodePort的端口是30948 $ ks NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE example-test NodePort 10.</description>
    </item>
    
    <item>
      <title>【算法系列】用一个栈实现另一个栈的排序</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/5/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/5/</guid>
      <description>题目要求 一个栈中元素的类型为整型，现在想将该栈从顶到底按从小到大的顺序排序，只允许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？
解题思路  申请一个新的help栈，不断从原有栈中获取数据, 去跟新的help栈的栈顶数据相比; 如果符合排序要求，就push到help栈中 如果不符合排序要求，就从help栈中pop出栈顶数据，push到原栈中，直至符合排序要求 最终原栈被清空，help栈是全部排好序的栈，重新一股脑写回来即完成栈排序  golang实现 package main // SortStark stark top --&amp;gt; stark bottom(from small to big) func SortStark(stk *Stack) { helpStack := NewStack() // 1.</description>
    </item>
    
    <item>
      <title>API网关对比</title>
      <link>https://zhangsiming-blyq.github.io/post/apigateway/</link>
      <pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/apigateway/</guid>
      <description>kong、apisix是当前比较火的两款开源api网关，本文对比了二者的部署、使用方式；提供一个简单的参考; 对于kong，大家都比较熟悉，但是对于apisix可能熟悉的并不多，那么kong、apisix在使用方式，功能命名上是否有相似，还是理念不同，请看下文。
 一、kong 1.1 安装 # 安装kong $ helm repo add kong https://charts.</description>
    </item>
    
    <item>
      <title>ansible-playbook 详解</title>
      <link>https://zhangsiming-blyq.github.io/post/ansible-playbook/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/ansible-playbook/</guid>
      <description>Ansible 是一个开源的基于 OpenSSH 的自动化配置管理工具。可以用它来配置系统、部署软件和编排更高级的 IT 任务，比如持续部署或零停机更新。
 一、ansible 简介  Ansible 的主要目标是简单和易用，并且它还高度关注安全性和可靠性。基于这样的目标，Ansible 适用于开发人员、系统管理员、发布工程师、IT 经理，以及介于两者之间的所有人。Ansible 适合管理几乎所有的环境，从拥有少数实例的小型环境到有数千个实例的企业环境。</description>
    </item>
    
    <item>
      <title>【算法系列】猫狗队列</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/4/</link>
      <pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/4/</guid>
      <description>题目要求 狗和猫都实现了Pet接口，可以用getPetType()查看对应的动物类型; NewDog()、NewCat()可以分别新建狗猫对象。
type Pet interface { getPetType() string } type fatherPet struct { Type string } func (fp *fatherPet) getPetType() string { return fp.</description>
    </item>
    
    <item>
      <title>【算法系列】如何仅用递归函数和栈操作逆序一个栈</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/3/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/3/</guid>
      <description>题目要求 一个栈依次压入1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1。将这个栈转置后，从栈顶到栈底为1、2、3、4、5，也就是实现栈元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。
解题思路  一个函数实现返回栈内数据，用于返回栈底元素，当栈空的时候停止  另一个函数接受栈底元素并将每一个的数据重新压入栈中，即可实现逆序   golang实现 package main import &amp;#34;fmt&amp;#34; func getAndRemoveLastElement(stack *Stack) int { result := stack.</description>
    </item>
    
    <item>
      <title>【算法系列】由两个栈组成的队列</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/2/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/2/</guid>
      <description>题目要求 编写一个类，用两个栈实现队列，支持队列的基本操作：add、poll、peek
解题思路  栈的特点是后进先出、队列的特点是先进先出 一个栈作为压入栈，另一个栈作为弹出栈，只要把压入栈的数据再压入弹出栈顺序就恢复回来了   golang实现 需要注意的是，因为只能保证每次从stackPush到stackPop的数据是连贯的, 所以stackPush在向stackPop压数据的时候必须一次性将全部数据压入, 并且只有stackPop为空时，才进行一次性压入操作。</description>
    </item>
    
    <item>
      <title>【算法系列】设计一个有getMin功能的栈</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/1/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/1/</guid>
      <description>题目要求  pop、push、getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构  解题思路  使用两个栈，starkData和stackMin 每次压入starkData时候同时比较和stackMin顶部数据大小，小于stackMin顶部数据就将新的最小值压入栈  golang实现 golang内置数据结构不包括栈，定义一个栈:</description>
    </item>
    
    <item>
      <title>client-go watch接口隔一段时间自动退出怎么办？</title>
      <link>https://zhangsiming-blyq.github.io/post/retrywatcher/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/retrywatcher/</guid>
      <description>在使用client-go的watch接口时候碰到异常退出问题，查了一下google没有多少信息，于是扒了一下代码，把自己踩的坑记录下来方便以后自查自纠。
 使用client-go watch接口 1. 如何watch 由于kubernetes整合了etcd的watch功能，我们可以通过watch操作去建立一个长连接，不断的接收数据；这种方式要优于普通的反复轮询请求，降低server端的压力;
使用client-go调用对应对象的Watch()方法之后，会返回一个watch.Event对象，可以对其使用ResultChan()接受watch到的对象。
pod, err := mycluster.</description>
    </item>
    
    <item>
      <title>python yield详解</title>
      <link>https://zhangsiming-blyq.github.io/post/python-yield/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/python-yield/</guid>
      <description>讲解python中迭代器、生成器、以及yield字段的常见使用场景。
 Iterators python中对象实现了__iter__()和__next__()两个方法，我们就成它是可迭代对象(iterables)，通过__iter__()可以返回一个迭代器对象(iterators)
 __iter__()方法：返回迭代器对象本身 __next__()方法：返回容器的下一个元素，在结尾时引发一个StopIteration异常终止迭代器  lst = [1, 2, 3] print(type(lst)) new_iter = lst.</description>
    </item>
    
    <item>
      <title>prometheus 监测 kubernetes 控制平面</title>
      <link>https://zhangsiming-blyq.github.io/post/monitor-control-plane/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/monitor-control-plane/</guid>
      <description>对于 kubernetes 集群的控制平面组件，监控是必要的, 他可以帮助我们获取到集群的整体负载压力，并在核心组件出问题的时候配合告警让管理员及时发现问题，及时处理，更稳定的保证集群的生命周期。
 一、Prometheus 如何自动发现 Kubernetes Metrics 接口?</description>
    </item>
    
    <item>
      <title>指数基金投资指南摘记</title>
      <link>https://zhangsiming-blyq.github.io/post/indexfund/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/indexfund/</guid>
      <description>股神巴菲特说：“通过定期投资指数基金，一个什么都不懂的业余投资者竟然往往能够战胜大部分专业投资者；指数基金追踪指数，对基金经理没有过多依赖；每个指数基金会同时投资几十只甚至上百只股票，可以最大化分散投资者的非市场风险；而且在所有同类基金里，指数基金的费率也是最低的。”
 宽基指数基金  上证50指数：上交所选出沪市规模最大、流动性最好、最具有代表性的50只股票组成样本股，反应沪市最具影响力的一批优秀大盘企业的整体状况 沪深300指数：由中证指数公司开发，从上交所和深交所挑选规模最大、流动性最好的300只股票，国内股市最具代表性的指数 中证500指数：将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，剩下的公司中选择日均总市值排名前500名的企业，作为中证500指数 创业板指数：放在深交所下面的，给达不到主板上市条件的小企业开放的门槛更低的市场；创业板综指指的是所有创业板上市公司的股价平均表现；创业板指数是反应创业板最主要的100家企业的平均表现  以上四种指数按照市值加权，股票规模越大，指数中权重越高。</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://zhangsiming-blyq.github.io/about/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/about/</guid>
      <description>专注于IT互联网，包括但不限于kubernetes、Go语言(golang)、python、shell、linux等
百里英骐  说点什么  备注 本站所有内容本着传播正能量，促进互相学习的基本原则, 可能会引用一些互联网上公开的内容。 如有侵权，请联系1030728296@qq.com，立马删~</description>
    </item>
    
    <item>
      <title>浅谈 containerd</title>
      <link>https://zhangsiming-blyq.github.io/post/containerd/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/containerd/</guid>
      <description>伴随着kubernetes对docker的弃用，containerd开始进入大众视野；相比于kubelet中集成docker-shim连接docker，docker再次条用containerd去管理容器，直接使用containerd可以通过原生CRI接口的调用实现容器runtime，简化了调用链路，更加的灵活可靠。
 一、安装使用 ctr 管理 containerd # Install Dependent Libraries $ sudo apt-get update $ sudo apt-get install libseccomp2 # 下载 # 目前是下载的1.</description>
    </item>
    
    <item>
      <title>足迹</title>
      <link>https://zhangsiming-blyq.github.io/footprints/</link>
      <pubDate>Tue, 22 Apr 1997 11:58:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/footprints/</guid>
      <description>2022-10-15 姥姥家阳台从窗户往下看，每天都有一只猫咪焦急地等待它的午饭 2022-10-10 西三环北路，首都师范大学北二区到北一区必经之路过街天桥 2022-10-10 夜晚 永定门城楼 2022-10-07 寿司拼盘 2022-10-05 东三环主路 2022-10-02 360大厦路口 2022-09-30 天桥演艺厅 </description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://zhangsiming-blyq.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>https://zhangsiming-blyq.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
