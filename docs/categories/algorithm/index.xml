<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on </title>
    <link>https://zhangsiming-blyq.github.io/categories/algorithm/</link>
    <description>Recent content in algorithm on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sun, 18 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangsiming-blyq.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【算法刷题系列】第4天 24. 两两交换链表中的节点, 19. 删除链表的倒数第 N 个结点, 面试题 02.07. 链表相交, 142. 环形链表 II</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day4/</link>
      <pubDate>Sun, 18 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day4/</guid>
      <description>
        
          
            收获总结 虚拟头节点的使用：虚拟头节点（Dummy Head）是处理链表问题的一大利器，尤其在增删节点操作中。通过引入虚拟头节点，可以避免处理链表头部时遇到的特殊情况，如删除第一个节点或在第一个节点前插入新节点。这不仅简化了代码，还减少了需要额外考虑的边界条件。例如，在处理 19. 删除链表的倒数第 N 个结点 时，虚拟头节点能够让双指针操作统一化，避免对头节点的单独处理。
双指针技术：双指针技术是链表问题中的核心工具，特别是在处理链表长度不一致、链表中查找特定节点、或检测链表是否存在环时。双指针通常有两种应用方式：
快慢指针：通过让一个指针每次走两步（快指针），另一个指针每次走一步（慢指针），这种方法能有效检测链表中的环（如 142. 环形链表 II）。当快慢指针相遇时，表明链表中存在环。随后，通过调整指针，可以精确找到环的起点。 同步指针：在链表相交问题中（如 面试题 02.07. 链表相交），同步指针的应用非常巧妙。让两个指针分别从两个链表的头开始遍历，当其中一个指针走到链表末尾时切换到另一个链表的头部，最终两个指针会在相交点相遇。这种方法的妙处在于，它平衡了链表长度的差异，使得指针在正确的位置相遇。 内置数据结构的应用：在处理链表问题时，合理使用内置的数据结构（如 map）可以大大提高解决问题的效率。例如，在检测链表是否有环时，使用哈希表可以记录已经访问过的节点，一旦再次访问到相同的节点，就可以立即判定链表中存在环，并找到环的入口。这种方法尽管增加了空间复杂度，但通常能够显著降低时间复杂度，是时间换空间的一种常见手段。
画图和理清思路：链表操作往往涉及多步节点指针的调整，容易出现操作顺序错误导致链表断裂或死循环的问题。因此，在进行复杂链表操作之前，通过画图来理清每一步的指针变动，明确节点间的连接关系，是非常必要的。比如在解决 24. 两两交换链表中的节点 问题时，通过画图可以清晰地看到每次交换后的链表结构，有助于正确实现节点交换。
操作的标准化和优化：在链表操作中，保持节点连接的正确性是最重要的。在实现代码时，应尽量避免无效或重复的操作。例如，在删除节点时，应确保先处理前驱节点的 next 指针，再释放目标节点的内存。同时，在实际开发中，掌握一些标准化的代码模板（如增删节点的通用代码框架）能够帮助减少错误，提高代码的复用性和开发效率。
题目解析 题目1：24. 两两交换链表中的节点 题目描述: 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯地改变节点内部的值，而是需要实际进行节点交换。
示例:
1输入: head = [1,2,3,4] 2输出: [2,1,4,3] 解法总结: 这个问题要求我们在链表中两两交换相邻的节点。为了简化操作，可以引入一个虚拟头节点（dummy head），它指向原链表的头节点，这样可以统一对头节点和后续节点的处理。然后使用双指针遍历链表，分别指向当前待交换的两个节点及其前驱节点。关键在于每次交换时，需要提前保存第二个节点的下一个节点，以防止链表断裂。假设1-&amp;gt;2-&amp;gt;3-&amp;gt;4是待交换的两个节点，交换过程如下：
将pre指向2 将2指向1 将1指向3 将pre指向1 将cur指向3 重复上述步骤，直到cur或cur.Next为空 代码实现:
1/** 2 * Definition for singly-linked list. 3 * type ListNode struct { 4 * Val int 5 * Next *ListNode 6 * } 7 */ 8func swapPairs(head *ListNode) *ListNode { 9	// 1.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法刷题系列】第3天 203.移除链表元素, 707.设计链表, 206.反转链表</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day3/</link>
      <pubDate>Fri, 16 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day3/</guid>
      <description>
        
          
            学习内容 学习文档：
链表讲解
收获总结 链表概述 链表是一种基础的数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针（或引用）。链表的最后一个节点指向 null，表示链表的末尾。链表动态扩展性强，适合频繁插入和删除操作。
链表的定义 链表有多种类型，最常见的是单链表和双链表。
单链表：每个节点包含数据和指向下一个节点的指针 next。链表的头节点指向第一个节点，最后一个节点的 next 指向 null。
Golang 单链表定义：
1type ListNode struct { 2 Val int 3 Next *ListNode 4} 双链表：每个节点包含数据、指向下一个节点的指针 next 和指向前一个节点的指针 prev，允许双向遍历。
Golang 双链表定义：
1type ListNode struct { 2 Val int 3 Next *ListNode 4 Prev *ListNode 5} 注意事项 循环的时候参考数组，初始条件是i,j; 链表就是cur, cur.Next 链表的第一个节点比较特殊，处理的时候需要特殊处理；引入一个空的头节点dummyHead，可以简化很多操作(一视同仁) 链表的指针就是ListNode本身，因为任何一个ListNode都可以根据Next进行移动; 双指针解法的时候每一个指针都应该是一个ListNode 链表元素的内存分布 链表节点的内存分布不连续，节点在内存中的位置是随机分配的。这使得链表可以灵活地增长或缩小，但查找元素的时间复杂度较高，因为需要从头节点开始逐一遍历。
节点的插入与删除 插入节点：
头部插入：新节点的 next 指向当前头节点，并将链表头节点更新为新节点，时间复杂度为 O(1)。 尾部插入：单链表需要遍历链表找到最后一个节点，时间复杂度为 O(n)，双链表则直接访问尾节点，时间复杂度为 O(1)。 删除节点：
删除头节点：将头节点更新为下一个节点，时间复杂度为 O(1)。 删除指定节点：需要遍历链表找到待删除节点，时间复杂度为 O(n)。 题目解析 题目1：203.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法刷题系列】第2天 209. 长度最小的子数组, 59. 螺旋矩阵 II</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day2/</link>
      <pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day2/</guid>
      <description>
        
          
            学习内容 学习文档：
长度最小子数组讲解
螺旋矩阵II讲解
收获总结 滑动窗口： 在某些情况下，滑动窗口可以看作是一种特殊的双指针技术，其中两个指针 i 和 j（即左指针和右指针）从同一端开始，但移动的条件有所不同。滑动窗口的核心思想是通过右指针 j 不断向右扩展窗口，同时左指针 i 尽量向右收缩窗口，以找到满足特定条件的最小或最大窗口。
举例来说，假设你想找到数组 arr 中两个元素之间的差值等于 diff 的一对元素索引，这可以视为滑动窗口问题，右指针 j 用来扩展窗口，左指针 i 用来收缩窗口，直到找到满足条件的子数组。初始化时可以根据具体问题选择 i, j 都从 0, 0 开始，也可以 0, 1 这种情况。
题目解析 题目1：209. 长度最小的子数组 题目描述: 给定一个含有 n 个正整数的数组 nums 和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
示例:
1输入: target = 7, nums = [2,3,1,2,4,3] 2输出: 2 3解释: 子数组 [4,3] 是该条件下的长度最小的子数组。 解法总结: 该题可以通过滑动窗口技术来解决。我们使用两个指针 i 和 j，分别代表窗口的左右边界。首先，右指针 j 向右移动，扩展窗口，累加窗口内的元素和 sum。当 sum 大于或等于 target 时，开始收缩窗口（移动左指针 i），同时记录当前窗口的最小长度。通过这种方式，可以高效地找到满足条件的最短子数组长度。 这里需要注意的是，因为有可能第一个数就等于target，所以j也要从0开始，同时内侧判断条件也是for!
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法刷题系列】第1天 704. 二分查找，27. 移除元素, 977.有序数组的平方</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day1/</link>
      <pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/programmercarl/day1/</guid>
      <description>
        
          
            学习内容 学习文档：数组理论基础
收获总结 快速排序：
快速排序是一种基于分治法的排序算法。首先，选择一个基准元素，然后通过分区操作将数组划分为两部分，一部分元素小于基准值，另一部分元素大于基准值。递归地对这两部分进行排序，最终将数组排序完成。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func quickSort(arr []int, low, high int) { 6 if low &amp;lt; high { 7 pi := partition(arr, low, high) 8 quickSort(arr, low, pi-1) 9 quickSort(arr, pi+1, high) 10 } 11} 12 13func partition(arr []int, low, high int) int { 14 pivot := arr[high] 15 i := low - 1 16 for j := low; j &amp;lt; high; j++ { 17 if arr[j] &amp;lt; pivot { 18 i++ 19 arr[i], arr[j] = arr[j], arr[i] 20 } 21 } 22 arr[i+1], arr[high] = arr[high], arr[i+1] 23 return i + 1 24} 二分查找：
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Generate an array of window maximums</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/6/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/6/</guid>
      <description>
        
          
            Requirements There is a integer array arr and a window of size w that slides from the leftmost to the rightmost part of the array, with the window sliding one position at a time to the right. For example, the array is [4,3,5,4,3,3,6,7], and the window size is 3.
If the length of the array is n and the window size is w, then a total of n-w+1 window maxima are generated.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Use One Stack To Sort Another Stack</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/5/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/5/</guid>
      <description>
        
          
            Requirements A stack whose elements are of type integer now wants to sort the stack from top to bottom in order from smallest to largest, and only one stack is allowed to be requested. Other than that, new variables can be requested, but no additional data structures can be requested. How to complete the sorting?
Solution apply for a new help stack, keep getting data from the original stack, and compare it with the top data of the new help stack; if it meets the sorting requirements, then push it to the help stack if it does not meet the sorting requirements, pop the top data from the help stack and push it to the original stack until it meets the sorting requirements Finally, the original stack is emptied, and the help stack is the stack that is all sorted, so write it back again to complete the stack sorting.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Dog-Cat Queue</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/4/</link>
      <pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/4/</guid>
      <description>
        
          
            Requirements Dog and cat have implemented the Pet interface, you can use getPetType() to view the corresponding animal type; NewDog(), NewCat() can create new dog and cat objects respectively.
1type Pet interface { 2	getPetType() string 3} 4 5type fatherPet struct { 6	Type string 7} 8 9func (fp *fatherPet) getPetType() string { 10	return fp.Type 11} 12 13type Dog struct { 14	fatherPet 15} 16 17func NewDog() *Dog { 18	fmt.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | How To Inverse Order A Stack Using Only Recursive Functions And Stack</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/3/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/3/</guid>
      <description>
        
          
            Requirements A stack is pressed into 1, 2, 3, 4, 5, then from the top of the stack to the bottom of the stack is 5, 4, 3, 2, 1. After transposing this stack, from the top of the stack to the bottom of the stack is 1, 2, 3, 4, 5, that is, to achieve the reverse order of the stack elements, but only with recursive functions to achieve, can not use other data structures.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Queue Composed Of Two Stacks</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/2/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/2/</guid>
      <description>
        
          
            Requirements Write a class that implements a queue with two stacks and supports the basic operations of a queue: add, poll, peek
Solving Ideas stacks are characterized by last-in-first-out, queues are characterized by first-in-first-out one stack as a press-in stack, the other stack as a pop-up stack, as long as the data pressed into the press-in stack and then pressed into the pop-up stack order will be restored Golang Implementation Note that since the data from stackPush to stackPop is only guaranteed to be coherent each time, stackPush has to press all the data into stackPop at once, and only when stackPop is empty.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Designing A Stack With &#39;getMin&#39; Function</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/1/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/1/</guid>
      <description>
        
          
            Requirements the time complexity of pop, push, getMin operations are O(1) the design of the stack type can use the ready-made stack structure Solving Ideas use two stacks, starkData and stackMin compare the size of the top data of stackMin with that of starkData each time it is pressed in, and press the new minimum value onto the stack if it is smaller than the top data of stackMin Golang Implementation Golang built-in data structure does not include a stack, define a stack.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
