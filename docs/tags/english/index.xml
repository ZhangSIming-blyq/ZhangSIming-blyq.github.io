<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>English on </title>
    <link>https://zhangsiming-blyq.github.io/tags/english/</link>
    <description>Recent content in English on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 10 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangsiming-blyq.github.io/tags/english/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Deploy Kubernetes cluster via kubeadm</title>
      <link>https://zhangsiming-blyq.github.io/post/kubernetes/kubeadm/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/kubernetes/kubeadm/</guid>
      <description>
        
          
            1. Install kubeadm(kubelet kubectl) and docker https://docs.docker.com/engine/install/ubuntu/
Set up docker apt repository:
1# Add Docker&amp;#39;s official GPG key: 2sudo apt-get update 3sudo apt-get install ca-certificates curl 4sudo install -m 0755 -d /etc/apt/keyrings 5sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc 6sudo chmod a+r /etc/apt/keyrings/docker.asc 7 8# Add the repository to Apt sources: 9echo \ 10 &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \ 11 $(. /etc/os-release &amp;amp;&amp;amp; echo &amp;#34;$VERSION_CODENAME&amp;#34;) stable&amp;#34; | \ 12 sudo tee /etc/apt/sources.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Etcd Tutorial</title>
      <link>https://zhangsiming-blyq.github.io/post/linux/etcd-tutorial/</link>
      <pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/linux/etcd-tutorial/</guid>
      <description>
        
          
            Preface: This tutorial focuses exclusively on the Etcd v3 protocol. Throughout Etcd&#39;s history, two protocols have been employed: v2 and v3. However, v2 is considered outdated and not recommended for production environments. Furthermore, Etcd v2 and v3 have distinct data storage structures. As a result, you cannot use Etcd v2 to read data from Etcd v3 or use an Etcd v2 snapshot to restore data in Etcd v3. This document is tailored for Etcd instances containing v3 data.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Comprehensive Guide to Neovim</title>
      <link>https://zhangsiming-blyq.github.io/post/linux/neovim/</link>
      <pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/linux/neovim/</guid>
      <description>
        
          
            Neovim, a powerful editor often hailed as a third-party extension for Vim, boasts an impressive 70k stars on GitHub. This robust tool makes for an excellent default editor choice. This guide will take you through the installation process and equip you with effective typing techniques.
Installation GitHub Link
Neovim Installation On MacOS 1$ brew install neovim 2 3$ which nvim 4/usr/local/bin/nvim 5 6$ vim ~/.zshrc 7alias vim=&amp;#39;nvim&amp;#39; 8alias old_vim=&amp;#39;vim&amp;#39; 9 10# replace the normal vim with nvim 11$ which vim 12vim: aliased to nvim 13 14$ vim --version 15NVIM v0.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Closures In Golang And Python</title>
      <link>https://zhangsiming-blyq.github.io/post/golang/closure/</link>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/golang/closure/</guid>
      <description>
        
          
            For people new to Golang and Python, this article explains what closures are as well as sometips that need to know about when using closures in these two programming languages. To make it easier for you to copy down and run on your own server, the code section would provide the package, import, and other repeated parts. The negative aspect is that this results in some redundancy, so please understand if this causes any inconvenience.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Generate an array of window maximums</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/6/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/6/</guid>
      <description>
        
          
            Requirements There is a integer array arr and a window of size w that slides from the leftmost to the rightmost part of the array, with the window sliding one position at a time to the right. For example, the array is [4,3,5,4,3,3,6,7], and the window size is 3.
If the length of the array is n and the window size is w, then a total of n-w+1 window maxima are generated.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Use One Stack To Sort Another Stack</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/5/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/5/</guid>
      <description>
        
          
            Requirements A stack whose elements are of type integer now wants to sort the stack from top to bottom in order from smallest to largest, and only one stack is allowed to be requested. Other than that, new variables can be requested, but no additional data structures can be requested. How to complete the sorting?
Solution apply for a new help stack, keep getting data from the original stack, and compare it with the top data of the new help stack; if it meets the sorting requirements, then push it to the help stack if it does not meet the sorting requirements, pop the top data from the help stack and push it to the original stack until it meets the sorting requirements Finally, the original stack is emptied, and the help stack is the stack that is all sorted, so write it back again to complete the stack sorting.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Dog-Cat Queue</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/4/</link>
      <pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/4/</guid>
      <description>
        
          
            Requirements Dog and cat have implemented the Pet interface, you can use getPetType() to view the corresponding animal type; NewDog(), NewCat() can create new dog and cat objects respectively.
1type Pet interface { 2	getPetType() string 3} 4 5type fatherPet struct { 6	Type string 7} 8 9func (fp *fatherPet) getPetType() string { 10	return fp.Type 11} 12 13type Dog struct { 14	fatherPet 15} 16 17func NewDog() *Dog { 18	fmt.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | How To Inverse Order A Stack Using Only Recursive Functions And Stack</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/3/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/3/</guid>
      <description>
        
          
            Requirements A stack is pressed into 1, 2, 3, 4, 5, then from the top of the stack to the bottom of the stack is 5, 4, 3, 2, 1. After transposing this stack, from the top of the stack to the bottom of the stack is 1, 2, 3, 4, 5, that is, to achieve the reverse order of the stack elements, but only with recursive functions to achieve, can not use other data structures.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Queue Composed Of Two Stacks</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/2/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/2/</guid>
      <description>
        
          
            Requirements Write a class that implements a queue with two stacks and supports the basic operations of a queue: add, poll, peek
Solving Ideas stacks are characterized by last-in-first-out, queues are characterized by first-in-first-out one stack as a press-in stack, the other stack as a pop-up stack, as long as the data pressed into the press-in stack and then pressed into the pop-up stack order will be restored Golang Implementation Note that since the data from stackPush to stackPop is only guaranteed to be coherent each time, stackPush has to press all the data into stackPop at once, and only when stackPop is empty.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ALGORITHM SERIES | Designing A Stack With &#39;getMin&#39; Function</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/1/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/1/</guid>
      <description>
        
          
            Requirements the time complexity of pop, push, getMin operations are O(1) the design of the stack type can use the ready-made stack structure Solving Ideas use two stacks, starkData and stackMin compare the size of the top data of stackMin with that of starkData each time it is pressed in, and press the new minimum value onto the stack if it is smaller than the top data of stackMin Golang Implementation Golang built-in data structure does not include a stack, define a stack.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Python Yield</title>
      <link>https://zhangsiming-blyq.github.io/post/python/python-yield/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/python/python-yield/</guid>
      <description>
        
          
            Explain the common usage scenarios of iterators, generators, and yield fields in Python.
Iterators Python object implements iter() and next() methods, we become iterable objects (iterables), through iter() can return an iterator object (iterators).
__iter__() method: return the iterator object itself __next__() method: returns the next element of the container, and raises a StopIteration Exception at the end to terminate the iterator 1lst = [1, 2, 3] 2print(type(lst)) 3new_iter = lst.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
