<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on bailiyingqi&#39;s blog</title>
    <link>https://zhangsiming-blyq.github.io/post/</link>
    <description>Recent content in Posts on bailiyingqi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Fri, 03 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangsiming-blyq.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>test</title>
      <link>https://zhangsiming-blyq.github.io/post/test/</link>
      <pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/test/</guid>
      <description>
        
          
            test
          
          
        
      </description>
    </item>
    
    <item>
      <title>聊一聊golang、python中的闭包</title>
      <link>https://zhangsiming-blyq.github.io/post/closure/</link>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/closure/</guid>
      <description>
        
          
            本文为golang、python新手通俗地解释什么是闭包，以及在这两种语言中使用闭包时候需要注意的地方。本文运行的时候保留了package、import等重复的代码部分，为了方便大家复制下来自己跑一下，劣势是导致有部分冗杂，还请理解。
什么是闭包? a closure is a record storing a function together with an environment.
闭包的两大要素：函数和环境
函数：指的是在闭包实际实现的时候，往往通过调用一个外部函数返回其内部函数来实现的。内部函数可能是内部实名函数、匿名函数或者一段lambda表达式; 环境：在实际中引用环境是指外部函数的环境，闭包保存/记录了它产生时的外部函数的所有环境; 综上，闭包是一种延伸了作用域的函数，他会保留定义函数时存在的自由变量(未在本地作用域中绑定的变量)的绑定，这样调用函数时，所以定义作用域不可用了，但是仍能使用那些绑定。下面看一下闭包的常见用法：
golang:
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func outer() func(v int) { 6 x := 1 7 return func(v int) { 8 y := x + v 9 fmt.Println(x) 10 fmt.Println(y) 11 } 12} 13 14func main() { 15 a := outer() 16 a(1) 17 a(2) 18} 19 20// 输出结果 211 222 231 243 golang例子里面的逻辑中，a是一个闭包，闭包函数为内部的func(v int){}, 闭包环境为外部的x, 由于&#39;捕获&#39;了外部环境，所以每次执行闭包x都是1，最后输出结果1,2,1,3。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用zap打造你的golang日志库</title>
      <link>https://zhangsiming-blyq.github.io/post/gozap/</link>
      <pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/gozap/</guid>
      <description>
        
          
            近期配置了uber家的zap日志库，觉得性能比较强，展示比较美观，在这里做一个分享，代码在第三部分可以自取。
为什么不选择原生log? 说起golang如何优雅的打印日志，任何一个golang的初学者大概都是用的原生log库，或者直接fmt.Println()...但是这种方式并不优雅，并且有以下缺点：
对于基础日志：不能细粒度区分info和debug级别的日志; 对于错误日志: 不支持除了fatal或者panic的普通error级别告知。 log示例 1package main 2 3import &amp;#34;log&amp;#34; 4 5func main() { 6 log.Print(&amp;#34;info or debug&amp;#34;) 7 log.Fatal(&amp;#34;fatal&amp;#34;) 8 log.Panic(&amp;#34;panic&amp;#34;) 9} 10 11// 输出如下 122022/11/23 22:23:32 info or debug 132022/11/23 22:23:32 fatal 14exit status 1 为什么不选择logrus? logrus也是比较常用的自定义日志库，不过因为Go语言是一门强类型的静态语言，而logrus需要知道数据的类型来打印日志，怎么办呢？实现方案是使用反射，这导致大量分配计数。虽然通常不是一个大问题（取决于代码），但是在大规模、高并发的项目中频繁的反射开销影响很大，所以这里不进行采用。
仓库链接: logrus
logrus示例 1package main 2 3import log &amp;#34;github.com/sirupsen/logrus&amp;#34; 4 5var logger = log.New() 6 7func main() { 8 // 这里可以通过WithFields来附加字段 9 logger.WithFields(log.Fields{&amp;#34;testfield&amp;#34;: &amp;#34;test&amp;#34;}).Info(&amp;#34;test info&amp;#34;) 10 logger.Info(&amp;#34;info&amp;#34;) 11 logger.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】生成窗口最大值数组</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/6/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/6/</guid>
      <description>
        
          
            题目要求 有一个整形数组arr和一个大小为w的窗口从数组最左边滑到最右边，窗口每次向右边滑一个位置。例如，数组为[4,3,5,4,3,3,6,7], 窗口大小为3时:
如果数组长度为n，窗口大小为w，则一共产生 n-w+1 个窗口最大值。请实现一个函数：
输入：整形数组arr，窗口大小为w 输出：一个长度为 n-w+1 的数组res，res[i]表示每一种窗口状态下的最大值，要求时间复杂度O(N*w) 解题思路 整体逻辑：
创建一个双端数组，我们需要根据不同情况从两端分别push和pop 核心就是循环这个arr，把最大的值在arr中的下标放到双端数组的最左端(对应下文程序中&amp;quot;for !bq.Empty() &amp;amp;&amp;amp; arr[i] &amp;gt; arr[bq.Back().(int)] {}&amp;quot;的处理) 当窗口走过对应数值区域的时候，把相应的数据进行过期(对应下文程序中&amp;quot;if bq.Front().(int) == i-w {}&amp;quot;) 注意，因为要输出长度为 n-w+1, 所以循环当&amp;quot;i &amp;gt;= w -1&amp;quot;的时候，才开始输出结果到res中 golang实现 1package main 2 3func Getmaxwindow(arr []int, w int) (res []int) { 4	res = []int{} 5	// 1. create a bidirectional queue to store the result 6	bq := newCustomQueue() 7	// 2. for i &amp;lt; length(arr) 8	for i := 0; i &amp;lt; len(arr); i++ { 9	// 3.
          
          
        
      </description>
    </item>
    
    <item>
      <title>谈谈kubernetes 证书认证那些事儿</title>
      <link>https://zhangsiming-blyq.github.io/post/kubernetes-certificate/</link>
      <pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/kubernetes-certificate/</guid>
      <description>
        
          
            kubernetes各个组件都是加密通信的, 那么都有哪些证书、各个证书怎么交互、这些证书什么时候过期，这个就变得至关重要; 本文引用了一些其他网络内容(均已附上原文链接)，并适当补充完善，用于让新手完善熟悉kubernetes证书体系(如有侵权联系邮箱可以删除)。
一、数字证书原理 1.1 传统非对称加密 1message --&amp;gt; (公钥加密) --&amp;gt; || 传输 || --&amp;gt; (私钥解密) --&amp;gt; message 注意:
1.这里与数字证书认证相反，是公钥加密私钥解密
2.公钥私钥需要是一个秘钥对
1.2 哈希函数 1message --&amp;gt; H(message) --&amp;gt; Hash message 处理加入一个随机数，然后得出结果(加盐); 可以有效缓解在输入值是一个有效的集合，哈希值也是固定长度被别人‘试’出来的几率
1message --&amp;gt; H(R|message) --&amp;gt; Hash message 1.3 数字证书 1.3.1 数字签名 数字签名；把数据根据私钥/哈希进行加密，然后必须要对应的公钥来进行解密认证才能确保数据安全。前半句的加密过程就叫做 &#39;数字签名&#39;
1.3.2 数字证书认证过程 Alice 想要通过证书加密让 Bob 安全读到自己的信息流程如下：
Alice 在本地生成 Private Key 和 CSR（Certificate Signing Request）。CSR 中包含了 Alice 的公钥和姓名，机构、地址等身份信息。 Alice 使用该 CSR 向证书机构发起数字证书申请。 证书机构验证 Alice 的身份后，使用 CSR 中的信息生成数字证书，并使用自己的 CA 根证书对应的私钥对该证书签名。 Alice 使用自己的 Private Key 对合同进行签名，然后将签名后的合同和自己的证书一起并发送给 Bob。 Bob 使用操作系统中自带的证书机构根证书中的公钥来验证 Alice 证书中的签名，以确认 Alice 的身份和公钥。(使用内置根证书确认身份并获取Alice证书) Alice 的证书验证成功后，Bob 使用 Alice 证书中的公钥来验证合同中数字签名。(使用刚刚获取的Alice证书(公钥)解析Alice发送的内容) 合同数字签名通过验证，可以证明该合同为 Alice 本人发送，并且中间未被第三方篡改过。 注意：
          
          
        
      </description>
    </item>
    
    <item>
      <title>浅谈kubernetes ingress机制</title>
      <link>https://zhangsiming-blyq.github.io/post/ingress-mechanism/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/ingress-mechanism/</guid>
      <description>
        
          
            ingress在将流量发往后端的时候是不经过kube-proxy的，ingress controller会直接和kube-apiserver进行交互，然后获取pod endpoints和service的对应关系，进行轮询，负载均衡到后端节点。
一、验证试验 从集群中删除kube-proxy，查看通过ingress的方式是否可以访问成功?
1# 实验中选择的是&amp;#34;iptables模式的kube-proxy&amp;#34; 2# 首先关闭kube-proxy 3$ sudo systemctl stop kube-proxy 4 5# 查看服务，ClusterIP的端口是8080，NodePort的端口是30948 6$ ks 7NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 8example-test NodePort 10.0.0.226 &amp;lt;none&amp;gt; 8080:30948/TCP 18h 9traefik NodePort 10.0.0.85 &amp;lt;none&amp;gt; 9000:30001/TCP,80:30002/TCP,443:31990/TCP 19h 10 11# 查看与&amp;#34;10.0.0.226&amp;#34;有关的iptables条目，得知访问&amp;#34;10.0.0.226&amp;#34;且目的端口是&amp;#34;8080&amp;#34;的流量会发送给KUBE-SVC-KNYNFDNL67C7KAZZ链 12$ sudo iptables -S -t nat | grep 10.0.0.226 13-A KUBE-SERVICES ! -s 10.0.0.0/24 -d 10.0.0.226/32 -p tcp -m comment --comment &amp;#34;traffic-dispatcher/example-test:port-8080 cluster IP&amp;#34; -m tcp --dport 8080 -j KUBE-MARK-MASQ 14-A KUBE-SERVICES -d 10.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】用一个栈实现另一个栈的排序</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/5/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/5/</guid>
      <description>
        
          
            题目要求 一个栈中元素的类型为整型，现在想将该栈从顶到底按从小到大的顺序排序，只允许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？
解题思路 申请一个新的help栈，不断从原有栈中获取数据, 去跟新的help栈的栈顶数据相比; 如果符合排序要求，就push到help栈中 如果不符合排序要求，就从help栈中pop出栈顶数据，push到原栈中，直至符合排序要求 最终原栈被清空，help栈是全部排好序的栈，重新一股脑写回来即完成栈排序 golang实现 1package main 2 3// SortStark stark top --&amp;gt; stark bottom(from small to big) 4func SortStark(stk *Stack) { 5	helpStack := NewStack() 6	// 1. while go through target stack until stack is empty 7	for stk.Len() &amp;gt; 0 { 8	cur := stk.Pop() 9	// 2. if cur &amp;lt; peek, push helpStack.pop() to target stack until cur &amp;gt; peek or helpStack is empty 10	for (helpStack.
          
          
        
      </description>
    </item>
    
    <item>
      <title>API网关对比</title>
      <link>https://zhangsiming-blyq.github.io/post/apigateway/</link>
      <pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/apigateway/</guid>
      <description>
        
          
            kong、apisix是当前比较火的两款开源api网关，本文对比了二者的部署、使用方式；提供一个简单的参考; 对于kong，大家都比较熟悉，但是对于apisix可能熟悉的并不多，那么kong、apisix在使用方式，功能命名上是否有相似，还是理念不同，请看下文。
一、kong 1.1 安装 1# 安装kong 2$ helm repo add kong https://charts.konghq.com 3$ helm repo update 4$ helm fetch kong/kong 5$ tar xf kong-2.5.0.tgz 6$ cd kong 7$ ls 8CHANGELOG.md Chart.yaml FAQs.md README.md UPGRADE.md charts ci crds example-values requirements.lock requirements.yaml templates values.yaml 9...需要配置 101. postgresql作为存储 112. 允许plain text调用admin API 12 13# 安装konga 14$ gc https://github.com/pantsel/konga.git 15$ ls konga 16Chart.yaml templates values.yaml 17...需要配置 181. 获取postgresql的secret写入连接信息 19 20# 部署 21$ helm install kong .
          
          
        
      </description>
    </item>
    
    <item>
      <title>ansible-playbook 详解</title>
      <link>https://zhangsiming-blyq.github.io/post/ansible-playbook/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/ansible-playbook/</guid>
      <description>
        
          
            Ansible 是一个开源的基于 OpenSSH 的自动化配置管理工具。可以用它来配置系统、部署软件和编排更高级的 IT 任务，比如持续部署或零停机更新。
一、ansible 简介 Ansible 的主要目标是简单和易用，并且它还高度关注安全性和可靠性。基于这样的目标，Ansible 适用于开发人员、系统管理员、发布工程师、IT 经理，以及介于两者之间的所有人。Ansible 适合管理几乎所有的环境，从拥有少数实例的小型环境到有数千个实例的企业环境。
1.1 ansible 变量优先级如下 command line values (eg &amp;quot;-u user&amp;quot;) role defaults inventory file or script group vars inventory group_vars/all playbook group_vars/all inventory group_vars/* playbook group_vars/* inventory file or script host vars inventory host_vars/*: inventory 下面的 hosts_vars 目录下的变量优先级大于 group_vars 目录下的 playbook host_vars/* host facts / cached set_facts play vars play vars_prompt play vars_files: vars_files 优先级大于同级别的 vars 字段(play 内定义) role vars (defined in role/vars/main.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】猫狗队列</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/4/</link>
      <pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/4/</guid>
      <description>
        
          
            题目要求 狗和猫都实现了Pet接口，可以用getPetType()查看对应的动物类型; NewDog()、NewCat()可以分别新建狗猫对象。
1type Pet interface { 2	getPetType() string 3} 4 5type fatherPet struct { 6	Type string 7} 8 9func (fp *fatherPet) getPetType() string { 10	return fp.Type 11} 12 13type Dog struct { 14	fatherPet 15} 16 17func NewDog() *Dog { 18	fmt.Println(&amp;#34;new dog&amp;#34;) 19	return &amp;amp;Dog{fatherPet{Type: &amp;#34;dog&amp;#34;}} 20} 21 22func (dog *Dog) getPetType() string { 23	return dog.fatherPet.Type 24} 25 26type Cat struct { 27	fatherPet 28} 29 30func NewCat() *Cat { 31	fmt.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】如何仅用递归函数和栈操作逆序一个栈</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/3/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/3/</guid>
      <description>
        
          
            题目要求 一个栈依次压入1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1。将这个栈转置后，从栈顶到栈底为1、2、3、4、5，也就是实现栈元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。
解题思路 一个函数实现返回栈内数据，用于返回栈底元素，当栈空的时候停止 另一个函数接受栈底元素并将每一个的数据重新压入栈中，即可实现逆序 golang实现 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func getAndRemoveLastElement(stack *Stack) int { 6	result := stack.Pop() 7	if stack.Len() == 0 { 8	return result.(int) 9	} else { 10	last := getAndRemoveLastElement(stack) 11	stack.Push(result) 12	return last 13	} 14} 15 16func reverse(stack *Stack) { 17	if stack.Len() == 0 { 18	return 19	} else { 20	garFuncReturn := getAndRemoveLastElement(stack) 21	reverse(stack) 22	stack.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】由两个栈组成的队列</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/2/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/2/</guid>
      <description>
        
          
            题目要求 编写一个类，用两个栈实现队列，支持队列的基本操作：add、poll、peek
解题思路 栈的特点是后进先出、队列的特点是先进先出 一个栈作为压入栈，另一个栈作为弹出栈，只要把压入栈的数据再压入弹出栈顺序就恢复回来了 golang实现 需要注意的是，因为只能保证每次从stackPush到stackPop的数据是连贯的, 所以stackPush在向stackPop压数据的时候必须一次性将全部数据压入, 并且只有stackPop为空时，才进行一次性压入操作。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5type TwoStackQueue struct { 6	stackPush *Stack 7	stackPop *Stack 8} 9 10func NewTwoStackQueue() *TwoStackQueue { 11	return &amp;amp;TwoStackQueue{ 12	stackPush: NewStack(), 13	stackPop: NewStack(), 14	} 15} 16 17func (tsq *TwoStackQueue) add(data interface{}) { 18	tsq.stackPush.Push(data) 19} 20 21func (tsq *TwoStackQueue) poll() interface{} { 22	if tsq.stackPop.Len() == 0 &amp;amp;&amp;amp; tsq.stackPush.Len() == 0 { 23	fmt.
          
          
        
      </description>
    </item>
    
    <item>
      <title>【算法系列】设计一个有getMin功能的栈</title>
      <link>https://zhangsiming-blyq.github.io/post/algorithm/1/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/algorithm/1/</guid>
      <description>
        
          
            题目要求 pop、push、getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 解题思路 使用两个栈，starkData和stackMin 每次压入starkData时候同时比较和stackMin顶部数据大小，小于stackMin顶部数据就将新的最小值压入栈 golang实现 golang内置数据结构不包括栈，定义一个栈:
支持NewStack()创建 支持Push(), Pop(), Peek(), Len(), Push支持任意类型(取值出来断言) 1package main 2 3import &amp;#34;sync&amp;#34; 4 5type ( 6	Stack struct { 7	top *node 8	length int 9	lock *sync.RWMutex 10	} 11	node struct { 12	value interface{} 13	prev *node 14	} 15) 16 17// NewStack Create a new stack 18func NewStack() *Stack { 19	return &amp;amp;Stack{nil, 0, &amp;amp;sync.RWMutex{}} 20} 21 22// Len Return the number of items in the stack 23func (s *Stack) Len() int { 24	return s.
          
          
        
      </description>
    </item>
    
    <item>
      <title>client-go watch接口隔一段时间自动退出怎么办？</title>
      <link>https://zhangsiming-blyq.github.io/post/retrywatcher/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/retrywatcher/</guid>
      <description>
        
          
            在使用client-go的watch接口时候碰到异常退出问题，查了一下google没有多少信息，于是扒了一下代码，把自己踩的坑记录下来方便以后自查自纠。
使用client-go watch接口 💡 全局的mycluster都等于*kubernetes.Clientset 1. 如何watch 由于kubernetes整合了etcd的watch功能，我们可以通过watch操作去建立一个长连接，不断的接收数据；这种方式要优于普通的反复轮询请求，降低server端的压力;
使用client-go调用对应对象的Watch()方法之后，会返回一个watch.Event对象，可以对其使用ResultChan()接受watch到的对象。
1pod, err := mycluster.Clusterclientset.CoreV1().Pods(appNamespace).Watch(context.TODO(), metav1.ListOptions{LabelSelector: label}) 2if err != nil { 3 log.Error(err) 4} 5... 6event, ok := &amp;lt;-pod.ResultChan() 7if !ok { 8 log.Error(err) 9} 异常：watch接口自动断开 1. 现象 在使用过程中，watch操作持续一段时间就会自动断开
2. 排查 我们进入watch包里面找到streamwatcher.go，其中节选了一些重要片段：
1type StreamWatcher struct { 2	sync.Mutex 3	source Decoder 4	reporter Reporter 5	result chan Event 6	stopped bool 7} 8... 9func NewStreamWatcher(d Decoder, r Reporter) *StreamWatcher { 10	sw := &amp;amp;StreamWatcher{ 11	source: d, 12	reporter: r, 13	// It&amp;#39;s easy for a consumer to add buffering via an extra 14	// goroutine/channel, but impossible for them to remove it, 15	// so nonbuffered is better.
          
          
        
      </description>
    </item>
    
    <item>
      <title>python yield详解</title>
      <link>https://zhangsiming-blyq.github.io/post/python-yield/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/python-yield/</guid>
      <description>
        
          
            讲解python中迭代器、生成器、以及yield字段的常见使用场景。
Iterators python中对象实现了__iter__()和__next__()两个方法，我们就成它是可迭代对象(iterables)，通过__iter__()可以返回一个迭代器对象(iterators)
__iter__()方法：返回迭代器对象本身 __next__()方法：返回容器的下一个元素，在结尾时引发一个StopIteration异常终止迭代器 1lst = [1, 2, 3] 2print(type(lst)) 3new_iter = lst.__iter__() 4print(type(new_iter)) 5 6# Output 7&amp;lt;class &amp;#39;list&amp;#39;&amp;gt; 8&amp;lt;class &amp;#39;list_iterator&amp;#39;&amp;gt; for循环实际上就是通过__iter__()获取iterators，然后进行__next__()取值，直到StopIteration
Generators&amp;amp;yield Generators是一种特殊的迭代器(iterators)。如果函数中任意位置存在yield字段，当你调用函数，函数不会直接执行，而是会返回一个生成器(generators)。另外生成器(generators)还支持生成器表达式（类似于列表，只是将[]换成了()）
1def test(): 2 print(&amp;#34;for test&amp;#34;) 3 yield 0 4gen1 = test() 5print(type(gen1)) 6gen2 = (x*x for x in range(0, 3)) 7print(type(gen2)) 8 9# Output 10&amp;lt;class &amp;#39;generator&amp;#39;&amp;gt; 11&amp;lt;class &amp;#39;generator&amp;#39;&amp;gt; yield 区别于迭代器(iterators)会把所有的内容全部储存到内存中，生成器(generators)会随着__next__()的不断调用分配内存
每次生成器(generators)会运行到yield字段，然后将生成器(generators)状态保存返回；下次调用__next__()会继续从当前位置继续，到达下一个yield字段。一直到StopIteration停止。看一下下面例子：
1def test(): 2 print(&amp;#34;start&amp;#34;) 3 yield 0 4 print(&amp;#34;end&amp;#34;) 5 yield 1 6 7gen1 = test() 8print(gen1.
          
          
        
      </description>
    </item>
    
    <item>
      <title>prometheus 监测 kubernetes 控制平面</title>
      <link>https://zhangsiming-blyq.github.io/post/monitor-control-plane/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/monitor-control-plane/</guid>
      <description>
        
          
            对于 kubernetes 集群的控制平面组件，监控是必要的, 他可以帮助我们获取到集群的整体负载压力，并在核心组件出问题的时候配合告警让管理员及时发现问题，及时处理，更稳定的保证集群的生命周期。
一、Prometheus 如何自动发现 Kubernetes Metrics 接口? prometheus 收集 kubernetes 集群中的指标有两种方式，一种是使用 crd(servicemonitors.monitoring.coreos.com)的方式，主要通过标签匹配；另一种是通过 scrape_config，支持根据配置好的&amp;quot;relabel_configs&amp;quot;中的具体目标, 进行不断拉取(拉取间隔为&amp;quot;scrape_interval&amp;quot;)
配置权限： k8s 中 RBAC 支持授权资源对象的权限，比如可以 get、list、watch 集群中的 pod，还支持直接赋予对象访问 api 路径的权限，比如获取/healthz, /api 等, 官方对于 non_resource_urls 的解释如下：
non_resource_urls - (Optional) NonResourceURLs is a set of partial urls that a user should have access to. *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
          
          
        
      </description>
    </item>
    
    <item>
      <title>指数基金投资指南摘记</title>
      <link>https://zhangsiming-blyq.github.io/post/indexfund/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/indexfund/</guid>
      <description>
        
          
            股神巴菲特说：“通过定期投资指数基金，一个什么都不懂的业余投资者竟然往往能够战胜大部分专业投资者；指数基金追踪指数，对基金经理没有过多依赖；每个指数基金会同时投资几十只甚至上百只股票，可以最大化分散投资者的非市场风险；而且在所有同类基金里，指数基金的费率也是最低的。”
宽基指数基金 上证50指数：上交所选出沪市规模最大、流动性最好、最具有代表性的50只股票组成样本股，反应沪市最具影响力的一批优秀大盘企业的整体状况 沪深300指数：由中证指数公司开发，从上交所和深交所挑选规模最大、流动性最好的300只股票，国内股市最具代表性的指数 中证500指数：将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，剩下的公司中选择日均总市值排名前500名的企业，作为中证500指数 创业板指数：放在深交所下面的，给达不到主板上市条件的小企业开放的门槛更低的市场；创业板综指指的是所有创业板上市公司的股价平均表现；创业板指数是反应创业板最主要的100家企业的平均表现 以上四种指数按照市值加权，股票规模越大，指数中权重越高。
红利指数：是近十几年兴起的一类比较特殊的策略加权基金；我们都知道股票是会发放股息的，也就是现金分红；业绩比较好的公司会每年从净利润中拿出一部分，以现金分红的形式回馈股东；而红利指数就是按照分红进行加权，组成指数基金。常见的有上证红利指数、中证红利指数、深证红利指数和红利机会指数 基本面指数：基本面基本覆盖了一个公司运营的各个方面，比如营业收入、现金流、净资产、分红等，按照基本面进行加权的叫做基本面指数 央视财经50指数：专家们投票选出来的50只股票，和专家的选股能力息息相关 恒生指数：投资中国香港上市的公司中规模最大的50家企业 H股指数：公司在内地注册，但是在香港上市，这样的公司就是H股；H股指数的全程是恒生中国企业指数 上证50AH优选指数：很多公司同时在A股和H股上市，关系紧密；买入AH股中相对便宜的那个，卖出相对贵的那个，利用这一原理来获取超额收益的组成上证50AH优选指数 纳斯达克100指数：美股纳斯达克规模最大的100家大型企业 标普500指数：以大盘股为主，有500只成分股；标普500是一个附带主观判断的蓝筹股指数，包括公司各个行业分布、大小型公司的选择都比较均匀 上证综指：上交所全部的上市公司组成 中证100指数：沪深300中选择前100组成、还有类似的中证800、中证1000、中证全指 等权重指数：等权重指数则是分配给每个成分股完全相同的权重 行业指数基金 优秀行业： 必须消费：主要是维持我们正常生活所需要的各种消费品、例如饮料、酒、农副食品等 医药行业：每个人都离不开生老病死，医药是人类的基本需求 可选消费：饮料、烟草等常用日用消费品，一般单价比较低、消费频率大，也是刚需 养老产业：多行业混合的产业，覆盖了多个行业，包括医疗保健、信息技术、日常消费、可选消费、甚至包括保险公司这种金融行业 强周期性行业 银行业：银行的周期性受宏观经济的影响较大，经济处于下行周期，银行利差收益减少，利益就变差；经济好转时，银行效益就会变好 证券业 地产业 其他： 军工行业 环保行业 白酒行业 常见的估值指标 市盈率：公司市值/公司盈利，反映了我们愿意为了获取1元的净利润付出多少代价(市盈率10表示我们愿意为了1元盈利付出10元)；也可以反推估算市值(根据公司年净利润乘市盈率可以计算市值)；适用于流通性好，盈利稳定的公司 盈利收益率：公司盈利/公司市值，一般来说盈利收益率越高公司的估值就越低，公司越有可能被低估；适用于流通性好，盈利稳定的公司 市净率：公司市值/公司净资产，净资产就是资产减去负债；当企业的资产大多是比较容易衡量价值的有形资产，并且使长期保值的资产时，比较适合用市净率来估值 股息率：过去一年公司的现金分红/公司市值，股息率衡量的就是现金分红的收益率；盈利收益率*分红率=股息率；分红率一般是公司预先就设置好了，连续多年不会有什么改变；股息率会随之股价波动，股价越低，股息率越高 指数的估值查看”银行螺丝钉公众号”获取
挑选指数基金 盈利收益率法： 投资方法：
盈利收益率大于10%时，开始(坚持)定投 盈利收益率小于10%，大于6.4%的时候暂停定投、继续持有；可以定投其他盈利收益率大于10%的品种 盈利收益率小于6.4%时，分批卖出 适用范围：流通性好、盈利比较稳定的品种：
指数：上证50、上证红利、中证红利、基本面50、央视50、上证50AH优选、恒生指数、H股指数
博格公式法： 指数基金未来的年复合收益率，等于指数基金的投资初期股息率，加上指数基金每年的市盈率变化率，再加上指数基金每年的盈利变化率：
股息率：从公证号估值获取 市盈率：市盈率呈周期性变化，如果看历史市盈率处于较低则未来大概率是会上涨的，这时候应该买入 盈利：一般情况国内经济上涨都会带来正收益 投资方法：
市盈率处于历史底部区域的时候坚持定投 市盈率进入正常估值，暂停定投，继续持有；可以定投其他处于底部的产品 市盈率进入历史较高区域的时候卖出 适用范围：盈利呈高速增长姿态的指数，可以使用博格公式对其进行判断。如果指数当前的市盈率处于它历史市盈率波动范围的较低区域，就可以投资它
指数：沪深300、中证500、创业板、红利机会指数、必需消费行业指数、医药行业指数、可选消费行业指数、养老产业指数
博格公式法-变种： 指数基金未来的年复合收益率，等于指数基金每年市净率的变化率，加上指数基金每年净资产的变化率
投资方法：
市净率处于历史底部区域的时候坚持定投 市净率进入正常估值，暂停定投，继续持有；可以定投其他处于底部的产品 市净率进入历史较高区域的时候卖出 适用范围：盈利处于不稳定状态或者盈利呈周期性变化，但行业没有长期亏损记录的指数
指数：证券行业指数、金融行业指数、非银金融行业指数、地产行业指数
在指数基金低估、值的投资的时候再进行定投
提高定投收益的五个小技巧 省下就是赚到：降低交易基金的费用 正确处理基金分红，能让长期收益上一个台阶(收益继续投入) 定投的频率选择：长期收益来看，一个月一投和一周一投收益几乎一致；如果月中看到大跌忍不住追加建议两周或者一周一投都可 定期不定额(盈利收益率法)：以盈利收益率首次达到10%以上开始投资基金额为基准，以后每个月定投的金额可以用下面公式计算：首次低谷时的定投资金*(当月的盈利收益率/首次的盈利收益率) 定期不定额(博格公式法)：首次低估时的定投资金*(首次的市盈率/当月的市盈率)；适用于博格公式变种的则是：首次低估时的定投资金*(首次的市净率/当月的市净率) 我应该投入多少资金到指数基金？ 对于手里有部分流动资产，可以用100减去自己当前的年龄，用得到的数值加上百分号就是适合投入到指数基金中的资金比例； 对于上班族：(每个月收入-各项开支)*0.
          
          
        
      </description>
    </item>
    
    <item>
      <title>浅谈 containerd</title>
      <link>https://zhangsiming-blyq.github.io/post/containerd/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhangsiming-blyq.github.io/post/containerd/</guid>
      <description>
        
          
            伴随着kubernetes对docker的弃用，containerd开始进入大众视野；相比于kubelet中集成docker-shim连接docker，docker再次条用containerd去管理容器，直接使用containerd可以通过原生CRI接口的调用实现容器runtime，简化了调用链路，更加的灵活可靠。
一、安装使用 ctr 管理 containerd 1# Install Dependent Libraries 2$ sudo apt-get update 3$ sudo apt-get install libseccomp2 4 5# 下载 6# 目前是下载的1.5.2 7$ wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz 8 9# 安装 10$ sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz 11# 初始化containerd配置 12$ containerd config default &amp;gt; /etc/containerd/config.toml 13# 修改默认的sandbox_image 14$ vim /etc/containerd/config.toml 15... 16sandbox_image = &amp;#34;registry.cn-beijing.aliyuncs.com/shannonai-k8s/pause:3.1&amp;#34; 17... 18 19# 启动服务 20sudo systemctl daemon-reload 21sudo systemctl start containerd 22 23# 查看版本 24$ ctr version 25Client: 26 Version: 1.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
